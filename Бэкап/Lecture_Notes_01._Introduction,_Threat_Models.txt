6.858 Лекция 1

Общие сведения:

Лабораторная работа 1: переполнение буфера. На следующей неделе будет практическое занятие для решения лабораторной № 1.

Введение:

Что такое безопасность?

Решение какой-либо задачи при наличии злоумышленника.

Многие системы подключены к сети Интернет, в которой есть злоумышленники. Таким образом, при проектировании многих систем может понадобиться решить вопрос безопасности, т.е. будет ли система работать при наличии злоумышленника?

Высокоуровневое понятие безопасности:

Политики (правила): задача, которую вы хотите решить. Например: только Алиса должна читать файл F.

Общие задачи: конфиденциальность, целостность, доступность.

Модель угрозы: предположение о том, что злоумышленник может делать. Например: может подобрать пароли, не может физически захватить файловый сервер.Лучше допустить ошибку предполагая, что злоумышленник может что-то сделать, чем наоборот, недооценить его возможности.

Механизм: небольшая часть, которую обеспечивает ваша система, чтобы помочь поддержать политики (правила). Например: учетные записи пользователей, пароли, права доступа к файлам, шифрование.

Конечная цель: лишить злоумышленника способов нарушить политику в рамках модели угроз. Обратите внимание, что цель ничего не говорит о механизме.

Почему обеспечивать безопасность трудно? Негативные задачи.

Необходимо гарантировать работу политики (правил), принимая во внимание модель угроз.

Сложно думать обо всех возможных путях, которыми злоумышленник может взломать систему.

Реальные модели угроз неокончательны (почти негативные модели).

Различие: легко проверить будет ли определенная задача защищать. Например: Алиса на самом деле может читать файл F.

Слабое звено имеет значение.

Повторяющийся процесс: проектирование, необходимое обновление модели угроз, и т.д.

Какой смысл, если мы не можем достичь абсолютной безопасности? В этом курсе мы будем расширять границы каждой системы, чтобы увидеть когда она сломается.

Каждая система вероятно будет иметь некоторый предел прочности ведущий к  возникновению угрозы.

Это не значит, что система бесполезная - все зависит от ситуации.

Важно понять, что система может делать и что не может.

В действительности нужно управлять рисками для безопасности и преимуществами системы безопасности.

Большая безопасность систем означает меньший риск (или последствие) от некоторых угроз.

Небезопасная система может потребовать ручного аудита для проверки атак и т.д.

Более высокая стоимость атаки означает, что больше злоумышленников воздержится от нее, т.е. чем больше трудозатрат на атаку, тем больше взломщиков откажется от этой мысли.

Повышение уровня безопасности часто делает новые функциональные возможности более удобными и надежными. Допустим вы хотите запустить какое-то приложение в вашей системе. Крупные компании иногда запрещают пользователям установку программ, которые не одобрены для их рабочих мест, отчасти из-за безопасности. Javascript в браузере изолирован, что делает его привлекательным (по большей части) для запуска нового кода/приложений без ручной проверки/одобрения (или виртуальных машин, или Native Client, или лучших механизмов изоляции ОС). Так же, VPNы делают его практичным для снижения риска подключения сотрудников к корпоративной сети из любого места, где есть интернет.

Что может пойти не так #1: проблемы с политиками.

Пример: почтовая учетная запись Сары Пэйлин.

http://en.wikipedia.org/wiki/Sarah_Palin_email_hack

Почтовые учетные записи Yahoo включают логин, пароль и секретный вопрос.

Пользователь может авторизоваться введя логин и пароль.

Если пользователь забыл пароль он может сбросить его ответив на секретный вопрос.

Секретные вопросы иногда могут быть легче для отгадывания (подбора) чем пароль.

Какой-то злоумышленник отгадал школу Сары Пэйлин, ее день рождения и т.д.

Количество политик для: возможности авторизоваться с любым паролем или секретным вопросом (ни в коем случае не применять "Только если пользователь забыл пароль, тогда...").

Пример: учетные записи Мэта Хонана на Amazon, Apple, Google и т.д. http://www.wired.com/gadgetlab/2012/08/apple-amazon-mat-honan-hacking/all/

Сброс пароля Gmail: отправляет ссылку проверки на резервный почтовый адрес. Google услужливо печатает часть резервного почтового адреса.

Резервным адресом Мэта Хонана была его учетная запись Apple @me.com.

Сброс пароля Apple: необходим платежный адрес, последние 4 цифры кредитной карты. Адрес может быть простым, но как получить 4 цифры номера кредитной карты пользователя?

Amazon: можно добавить кредитную карту к учетной записи, не требуется пароль.

Сброс пароля Amazon: введите любой из номеров кредитных карт пользователя.

Amazon: не будет выводить номера кредитных карт. Но будет показывать последние 4 цифры!

Пример: взлом учетной записи @N Twitter'а. https://medium.com/p/24eb09e026dd

Для пользователя может быть сложно подтвердить, что он действительно владелец аккаунта!

Как это решить?

Задумаемся о значении политик безопасности.

Некоторые проверочные инструменты политики могут помочь, но нужен способ, чтобы определить что плохо.

Сложности в распределенных ситстемах: не известно, что каждый человек делает. 

Что может пойти не так #2: проблемы с моделью угрозы/предположениями. 
Пример: не учитывается человеческий фактор, напр. фишинговые атаки.

Пользователь получает письмо запрашивающее продление срока действия почтовой учетной записи, перевод денег или...

Техническая поддержка принимает звонок от (убедительно звучащего) пользователя с просьбой сбросить пароль.

Бандитский криптоанализ ("Rubberhose cryptanalysis").

Пример: вычисляемые предположения со временем изменяются.

Система Kerberos МИТ использовала 56-битные DES ключи с середины 1980-х.

В то время казалось нормальным предположение о том, что злоумышленник не сможет проверить все 2^56 ключей.

Теперь это не так: теперь это стоит около 100$.

https://www.cloudcracker.com/dictionaries.html (у меня ссылка не открылась)

Несколько лет назад, в итоговом проекте по курсу 6.858 было показано, что можно получить любой ключ за день.

Пример: всем центрам сертификации, выдающим сертификаты SSL, можно полностью доверять.

Для соединения с веб-сайтом, поддерживающим SSL, браузер подтверждает сертификат.

Сертификат - это комбинация имени хоста сервера и криптографического ключа, подписанного каким-то доверенным центром сертификации.

Длинный список, состоящий из сотен центров сертификации, одобренных большинством браузеров.

Если какой-либо центр сертификации скомпроментирован, то злоумышленник может перехватить SSL соединения с помощью поддельного сертификата для любого имени хоста сервера.

В 2011 году два центра сертификации были скомпроментированы, выдавали поддельные сертификаты для множества доменов (google, yahoo, tor, ...), по-видимому использовалось в Иране.

http://en.wikipedia.org/wiki/DigiNotar

http://en.wikipedia.org/wiki/Comodo_Group
https://ru.wikipedia.org/wiki/Comodo (русский вариант)

В 2012 году центр сертификации случайно выпустил корневой сертификат, действительный для любого домена.

http://www.h-online.com/security/news/item/Trustwave-issued-a-man-in-the-middle-certificate-1429982.html

Пример: предположение, что ваше оборудование является надежным.

Если вашим злоумышленником оказывается АНБ, то это окажется плохим предположением.

https://www.schneier.com/blog/archives/2013/12/more_about_the. html (страница не существует)

Пример: предположение о хорошей степени случайности для шифрования.

Необходима высококачественная степень случайности для генерации ключей, которые могут быть подобраны. 
Проблема: встроенные устройства, виртуальные машины могут не иметь много степеней случайности.

В результате, многие ключи похожи или восприимчивы к атаке перебором.

https://factorable.net/weakkeys12.extended.pdf

Пример: обход военной безопасности ОС.

В 80-х военные поддерживали исследования в защите ОС.

Один неожиданный случай, в котором были скомпроментированы ОС - злоумышленник получил 

доступ к системе разработки и изменил код ОС.

Пример: обход файрволов.

Злоумышленники могут соединиться с небезопасным беспроводным соединением (wi-fi) за фаерволом.

Злоумышленники могут обмануть пользователя, который находится за фаерволом, чтобы он отключил его (фаервол).

Может быть достаточно просто кликнуть по ссылке http://firewall/?action=disable

Или может купить рекламу на CNN.com, указывающую на этот URL (эфективно)?

Пример: машины не подключенные к интернету безопасны?

stuxnet - червь, распространяющийся через специально созданные файлы на USB-накопителях.

Как это решить?

Создавать более подробные модели угроз, для понимания возможных уязвимостей.

Упрощенные, более общие модели угроз.

Лучшее проектирование может устранить/уменьшить зависимость от определенных допущений. 

Например, альтернативные модели доверия, которые не включают полностью доверенный протокол управления доступом (CAS).

Например, механизмы аутентификации, не поддающиеся фишингу.

Что может пойти не так #3: проблемы с механизмом -- баги.

Баги в механизме безопасности (например, ядре ОС) ведут к уязвимостям.

Если приложение обеспечивает безопасность, то баги на уровне приложения ведут к уязвимостям.

Пример: ограничение скорости подбора пароля в Apple iCloud.

https://github.com/hackappcom/ibrute

Люди часто выбирают слабые пароли; часто можно подобрать w/ несколько попыток (1K-1M)

Большинство сервисов, включая Apple iCloud, ограничивают скорость попыток входа в систему.

Сервис Apple iCloud имеет множество интерфейсов для прикладного программирования (API).

В одном таком интерфейсе (сервис "Найти мой iPhone") забыли реализовать ограничение скорости.

Злоумышленник сможет совершить множество попыток подобрать пароль.

Вероятно так же быстро как они могут посылать пакеты: >>M/day.

Пример: Отсутствие контроля доступа на веб-сайте кредитной карты Ситигруп.

http://www.nytimes.com/2011/06/14/technology/14security.html

Ситигруп позволяет пользователям кредитных карт обращаться к их счетам онлайн.

Страница аутентификации запрашивает имя пользователя и пароль.

Если аутентификация успешна, то идет перенаправление на сраницу с информацией о счете.

Ссылка на эту страницу (страницу с информацией о счете) включает некоторые номера.

Оказывается, эти номера были номерами счетов пользователей.

Но это еще не самое худшее, сервер не проверял, что вы прошли аутентификацию.

Злоумышленник пробовал разные номера и получал информацию о счетах различных людей.

Возможно, неправильная модель угроз - не соответствующая реальности?

Система безопасна, если злоумышленник просмотривает веб-сайт через браузер.

Система не безопасна, если злоумышленник генерирует новые ссылки на основании его собственной.

Сложно сказать, построили ли разработчики неверную модель угроз, или механизм имеет баги (глючит).

Пример: уязвимость в Java SecureRandom для Android приводит к краже Bitcoin. https://bitcoin.org/en/alert/2013-08-11-android

Биткойны (Bitcoin) могут быть потрачены кем угодно, кто знает приватный ключ владельца.

Многие приложения биткойн-кошельки на Android используют Java API SecureRandom.

Оказывается система иногда забывает определить набор начальных значений ГПСЧ (генератор псевдослучайных чисел).

В результате, некоторые биткойн-ключи оказалось легко подобрать.

Злоумышленники подбирали ключи, используя любые соответствующие биткойны.

Пример: баги в песочнице$^{1}$ (sandbox) (NaCl, Javascript, Java runtime).

$^{1}$ Песочница (sandbox) в программном обеспечении предполагает собой изолированное окружение для проведения экспериментальной доработки и/или модернизации какого-либо существующего продукта

Позволяют злоумышленнику избавиться от изоляции и выполнять операции, которые, как предполагалось, они не могут осуществить.

Пример: баг проверки имен SSL сертификата Moxie.

Нулевой байт против длины кодирования.

Пример: переполнение буфера (смотрим ниже).

Конкретный пример: переполнение буфера.

Рассмотрим web-сервер. Часто, код web-сервера отвечает за безопасность. Например, проверка какие ссылки могут быть доступны, проверка клиентских SSL сертификатов и т.д. Таким образом, ошибки в коде сервера могут привести к нарушению безопасности.

Какая модель угроз, политики?

Предположим, что злоумышленник может соединиться с web-сервером, ввести какие-либо входные данные.

Понятие политики довольно расплывчатое: только выполнять операции назначенные программистом?

Например, не хочется, чтобы злоумышленник мог украсть данные, обойти проверки, установить бэкдоры (backdoor -"черный ход" - путь обхода системы защиты).

Рассмотрим следующий упрощенный пример кода из, скажем, веб-сервера:

int read_req(void) { char buf[128];

int i; gets(buf);

i = atoi(buf); return i;

}

Демо-версия вместе с обсуждением ниже:

выполните

./readreq

1234

./readreq

12341234123412341234

./readreq AAAAAAAAAAAA....AAAA

gdb ./readreq

b read_req 
r

disas $eip
info reg
print &buf[0]
(взяла из оригинала)

x $ebp
x $ebp+4

disas 0x08048e5f
next

AAAAAAA...AAA
print &buf[0]
x $ebp

x $ebp+4
next

print &buf[0] ## почему сейчас только 128 бит?
x $ebp

x $ebp+4

disas $eip
next i
next i
disas $eip
info reg

x $esp
stepi
stepi

..

disas main

set {int}$esp = 0x.. ##из main
c

Что делает компилятор сгенерированный с точки зрения размещения памяти? х86 стэк:

Стэк растет вниз.

%esp указывает на последнюю (самую нижнюю) валидную ячейку в стэке.

%ebp указывает на значение %esp вызывающего.

(вырезать картинку из оригинала, ничего не переводить до следующих слов)

(здесь продолжение перевода)


Как злоумышленник воспользовался этим кодом?

Отправит длинные входные данные, перезапишет данные в стэке за пределами буфера.

Интересный кусочек данных: возвращает адрес, перемещается с помощью 'ret'.

Может установить обратный адрес для самого буфера, включить там какой-то код.

Откуда злоумышленник знает адрес буфера?

Что если одна машина имеет вдвое больше памяти?

К счастью для злоумышленника виртуальная память делает вещи (ячейки?) более определенными.

Для данной ОС и программы адреса часто будут одинаковыми.

Что случится если стэк растет вверх, а не вниз?

Посмотрите на кадр стэка для получения.

Что может сделать злоумышленник однажды выполнив код?

Использовать любые привилегии процесса.

Часто переполнение используется для получения легкого доступа в систему.

Изначально в Unix запустите терминал (shell) /bin/sh (что соответствует "shell code").

Если процесс запущен с правами супер пользователя (root) или Администратора, можно делать что угодно.

Даже если нет, можно по-прежнему отправлять спам, читать файлы (веб-сервер, базу данных), и т.д.

Можно атаковать другие машины за брандмауэром (фаерволом).

Почему программисты пишут такой код?

Раньше код не был подключен к интернету.

Программисты не задумывались о безопасности.

Множество стандартных функций были незащищенными (strcpy, gets, sprintf).

Даже защищенные версии имеют сбои (strncpy не нуль-терминирована https://goo.gl/D63BYI).

В общем, любые ошибки памяти могут превратиться в уязвимость.

Использование памяти после того как она была освобождена (использование после освобождения).

Если при записи перезаписать новую структуру данных, например функция ptr.

Если при чтении можно вызвать поврежденный указатель на функцию.

Освобождение одной и той же памяти дважды (дважды освобожденный).

Возможно, потому что malloc() позже вернул туже память дважды.
Прим.пер: http://cppstudio.com/post/856/ про функцию malloc()

Уменьшение стэка ptr за пределы стека, в какую-то другую память.

http://www.invisiblethingslab.com/resources/misc-2010/xorg-large-memory-attacks.pdf

Один байт случайной записи может привести к уязвимости.

http://www.openwall.com/lists/oss-security/2014/08/26/2

Может не нужно даже перезаписывать возвращаемый адрес или указатель на функцию.

Достаточно прочитать конфиденциальные данные, такие как ключ шифрования.

Достаточно изменить некоторые биты (например, int isLoggedIn, int isRoot).

Как избежать проблем механизма?

Уменьшить количество кода с критичной безопасностью.

Не следует полагаться на приложение целиком для обеспечения безопасности.

Лабораторная работа 2.

Избегать ошибок в коде с критичной безопасностью.

Например, не используйте функцию gets(), используйте функцию fgets(), которая может ограничивать длину буфера.

Используйте простые, хорошо протестированные механизмы безопасности ("Экономика механизма").

Проверяйте эти простые механизмы (множество причин, чтобы сделать это).

Избегайте разработки новых, одноразовых механизмов, которые могут содержать ошибки.

Хороший механизм поддерживает многопользовательские системы, политики (больше причин для проверки).

Примеры простых механизмов:
Контроль доступа на уровне ОС (но часто лучший)
Стевой брандмауэр (фаервол) (но часто лучший)
Шифрование, протоколы шифрования.

MIT OpenCourseWare

http://ocw.mit.edu

6.858 Безопасность информационных систем

Осень 2014 года.

Для получения информации о размещении ссылок на наши материалы или о наших Правилах использования, посетите http://ocw.mit.edu/terms.

Переведено на Нотабеноиде
http://translate.kursomir.ru/book/5/8

Переводчики: Chantico


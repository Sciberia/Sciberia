6.858 Лекция 2

Обзор атак с использованием переполнения буфера.

На прошлой лекции мы рассмотрели основы выполнения атаки переполнения буфера. Эта атака использовала некоторые замечания:

Программное обеспечение системы часто написано на C (операционные системы, файловые системы, базы данных, компиляторы, сетевые серверы, терминалы (консоли) и консольные утилиты)

C - по факту высокоуровневый ассемблер, итак...

o Выставляет сырые указатели на память
o Не выполняет проверки границ массива (потому что аппаратные средства не делают этого, а C хочет, чтобы вы были как можно ближе к аппаратным средствам)

При атаке так же использовались знания о том, как работает сод в х86 архитектуре:
o Указание, что стек растет
o Схема расположения переменных стека (esp, массивы и адреса возврата для функций)
void read_req() { char buf[128]; int i; gets(buf);

//. . . делать w/buf . . .

}

Что компилятор генерирует с точки зрения разметки памяти?

x86 стек выглядит примерно так:

%esp указывает на последнюю (самую нижнюю) валидную ячейку в стеке.
%ebp указывает на значение вызывающего %esp

Как злоумышленник использует этот код?

Отправит длинные входные данные, перезапишет данные в стеке за пределами буфера.
Важное замечание 1: злоумышленник может перезаписать адрес возврата и программно перейти в выбранное место!

Важное замечание 2: злоумышленник может установить адрес возврата на сам буфер, включая некоторый код х86 архитектуры там!

Что злоумышленники могут сделать однажды выполнив код?

Использовать любые привилегии процесса! Если процесс запущен с правами супер пользователя (root) или Администратора он может делать что угодно в системе. Даже если процесс запущен без прав супер пользователя (root) он может посылать спам, читать файлы и, что примечательно, атаковать или повреждать другие машины за брандмауэром (фаерволом).

Хммм, но почему ОС не предупреждает, что буфер переполнен?

ОС известно, ничего странного не произошло! Помните, что, в первом приближении, ОС вызывается веб-сервером, только когда сервер совершает операции ввода/вывода (IO (input/output)) или инструкции за такт (IPC (Instructions Per Cycle)). Кроме этого, ОС в основном сидит сложа руки и позволяет программе выполняться, полагаясь на таблицы страниц оборудования, для предотвращения подмены памяти процессов друг другом. Однако, защитные механизмы таблицы страницы не предотвращают переполнение буфера, с помощью процесса "против себя (вопреки себе)", поскольку переполнение буфера, и обратный адрес, и вся эта чепуха находится внутри валидного адресного пространства процесса.

Позже в этой лекции мы поговорим о вещах которые ОС "может" делать, чтобы сделать возможность переполнения буфера сложнее.

Исправление переполнения буфера.

Подход #1: Избегать баги (ошибки) в C коде.

Программист должен тщательно проверять размеры буферов, строк, массивов, и т.д. В частности, программист должен использовать стандартную библиотеку функций, которая принимает во внимание размер буфера (strncpy() вместо strcpy(), frets() вместо gets(), и т.д.).

Современные версии gcc и Visual Studio предупреждают вас ,когда программа использует небезопасные функции, такие как gets(). В целом, ВЫ НЕ ДОЛЖНЫ ИГНОРИРОВАТЬ ПРЕДУПРЕЖДЕНИЯ КОМПИЛЯТОРА. Относитесь к предупреждениям как к ошибкам!

Плюсы (Хорошо): В первую очередь избегайте проблемы!

Минусы (Плохо): Трудно гарантировать, что код не содержит ошибок (багов), особенно если база кода велика. Также, приложение само может определять функции управления буфером, которые не используют fgets() или strcpy() в качестве базовых (примитивов).

Подход#2: Создание инструментов, помогающих программистам находить ошибки (баги).
Например, мы можем использовать статический анализ для поиска проблем в исходном коде перед тем как его компилировать. Представьте, что у вас есть функция, похожая на эту:

void foo(int *p){ int offset;

int *z = p + offset; if(offset > 7){

bar(offset);
}

}

При статическом анализе потока управления мы можем сказать, что переменная offset не инициализированна (используется без инициализации). Оператор if также накладывает ограничения на вызов функции bar() при помощи переменной offset. Мы будем больше говорить о статическом анализе в последующих лекциях.

"Фаззинг" (“Fuzzers”), генерирующий случайные входы, может быть эффективен для поиска ошибок (багов). Обратите внимание, что фаззинг можно комбинировать со статическим анализом для максимального покрытия кода!

Минусы (Плохо): Трудно доказать полное отсутсвие ошибок (багов), особенно для небезопасного кода как C.
Плюсы (Хорошо): Даже частичный анализ полезен, поскольку в программах точно становится меньше ошибок (багов). Например, обширная проверка границ не может поймать все ошибки памяти, но может определить множество важных видов.

Подход #3: Использовать безопасный по памяти язык программирования (JavaScript, C#, Python).

Плюсы: Предотвращает ошибки повреждения памяти, не показывая необработанные адреса памяти программисту и проводя автоматическую сборку мусора.

Минусы: Низкоуровневый код ИСПОЛЬЗУЕТ необработанные адреса памяти. Поэтому базовая среда исполнения все еще нуждается в корректировке. Например, heap spraying атаки:
https://www.usenix.org/legacy/event/sec09/tech/full_papers/ratanaworabhan.pdf
https://www.corelan.be/index.php/2011/12/31/exploit-writing-tutorial-part-11-heap-spraying-demystified/

Минус: Все еще существует множество действующего кода на небезопасных языках программирования (Fortran и Cobol о, нет уж).
Минус: Возможно вам необходимо получить доступ к низкоуровневым характеристикам оборудования, потому что, например, вы пишете драйвер.
Минус: Производительность хуже чем в отлаженном приложении на C?
Все еще является большой проблемой, но аппаратные и высокоуровневые языки становятся лучше.
JIT плох, но это лучшее из того что придумало человечество!
asm.js имеет производительность как 2 C++! [http://asmjs.org/faq.html]

Пишите код аккуратно, чтобы избежать вызова сборщика мусора критическим путем.
Может быть вы плохой человек/язык программирования, шовинист, который не знает как правильно выбрать инструменты для работы. Если ваша задача ограничена скоростью ввода/вывода, сама скорость вычислений имеет гораздо меньшее значение. Так же не будьте глупцами, которые пишут программы работы с текстом на C.

Все 3 подхода, описанные выше, являются эффективными и широко используются, но на практике переполнение буфера все еще является проблемой.
Большой/сложный унаследованный код, написанный на C, широко распространен.
Даже недавно написанный код на C/C++ может иметь ошибки памяти.

Как мы можем уменьшить возможность переполнения буфера, несмотря на код с ошибками?

В "традиционном" переполнении буфера происходит две вещи:

Злоумышленник получает контроль над исполнением (программный счетчик)
Злоумышленник выполняет какой-то вредоносный код.

Какие трудности в этих двух шагах?
Требуется перезапись код указателя (которые позже вызываются). Распространенная цель - это обратный адрес использующий буфер в стеке. Любая ошибка памяти потенциально может работать на практике. Указатели на функции, виртуальные таблицы C++, обработчики исключений, и т.д.

Требуется некоторый интересный код в памяти процесса. Это часто легче чем #1, потому что:
легко поместить код в буфер и
процесс уже содержит много кода, который может быть использован.



Однако, злоумышленнику надо поместить этот код в предсказуемое место, так что злоумышленник сможет установить код указателя так, чтобы он указывал на вредоносный код!

1й подход к снижению риска: "осведомители" (англ. canaries) (например, StackGuard, gcc's SSP)

Идея: Хорошо, чтобы перезаписывать код указателя до тех пор, пока мы не поймаем его перед выполнением. Одна из ранних систем: StackGuard
Помещает осведомителя в стеке при входе, проверьте значение осведомителя перед возвращением.
Обычно требуется исходный код; компилятор добавляет проверки осведомителя.
В(вопрос): Где осведомитель на диаграмме стека?

О (ответ): Осведомитель должен идти перед адресом возврата в стеке, так что любое переполнение, которое переписывает адрес возврата будет так же переписывать осведомителя.

В: Предположим, что компилятор всегда создает осведомителя размером 4 байта от символа 'а'. Что в этом плохого?

О: Злоумышленник может включить подходящее значение осведомителя в переполнение буфера!

Таким образом, осведомитель должен быть либо трудно угадываемым, либо он может быть простым, но все еще защищающим от переполнения буфера. Ниже приведены примеры этих подходов.

"Завершающий осведомитель": четыре байта (0, CR, LF, -1)

Идея: Множество функций языка C рассматривают эти символы как терминаторы (например, gets(), sprintf()). В результате, если осведомитель соответствует одному из них, то дальнейшей записи не произойдет.

Случайный осведомитель генерируется во время инициализации программы: На сегодняшний день наиболее распространено (но вам нужны хорошие случайности!).

Какие виды уязвимостей не будут пойманы осведомителем стека?

Замена указателей функций перед осведомителем.
Злоумышленник может заменить указатель на данные, затем использовать это, чтобы делать записи случайной памяти.

 int *ptr = ...; char buf[128];

gets(buf); //Буфер переполняется и перезаписывается указатель. 
*ptr = 5; //Записывается адресс контролируемый злоумышленником!

//Осведомитель не может остановить такого рода вещи.

Переполнение кучи (указатели функций, виртуальные таблицы C++).
Переполнение функций malloc()/free()

int main(int argc, char **argv) { char *p, *q;

p = malloc(1024); q = malloc(1024);
if(argc >= 2)

strcpy(p, argv[1]); free(q);

free(p); return 0;

}

Предположим, что 2 блока памяти, записанные в p и q находятся в памяти рядом.

Предположим, что malloc и free представляют блоки памяти такие как:

Итак, переполнение буфера в p будет перезаписывать значение размера в блоке памяти q! Почему это является проблемой?

Когда free() объединяет два смежных свободных блока ей (free()) необходимо манипулировать указателями bkwd и fwd, а вычисление указателя использует размер, чтобы определить где живет(находится) структура блока свободной памяти!

p = get_free_block_struct(size);
bck = p->bk;
fwd = p->fd;
fwd
->bk = bck; //Записывает память!
bck->fd = fwd;   //Записывает память!



Блок свободной памяти представлен как структура C; повреждая значение размера злоумышленник может заставить free() работать с поддельной структурой, которая находится в контролируемой злоумышленником памяти и имеет контролируемые злоумышленником значения для прямого (forward) и обратного (backwards) указателей.

Если злоумышленник знает как free() обновляет указатели он может использовать этот код для записи произвольного значения в произвольное место. Например, злоумышленник может перезаписать обратный адрес.

Фактически детали немного сложнее: если вас интересуют "кровавые" подробности вам сюда: http://www.win.tue.nl/~aeb/linux/hh/hh-11.html
Самое главное, что осведомители стека не предотвратят эту атаку, потому что злоумышленник "перепрыгивает" осведомителя и пишет прямо на обратный адрес!

Итак, осведомители стека являются одним из способов уменьшения переполнений буфера в "дырявом" (забагованом) коде.

2й подход к снижению риска: проверка границ.

Общая цель: предотвратить неправильное использование указателя, проверяя, находятся ли указатели в диапазоне.

Проблема:В C может быть сложно отличить действительный (валидным) указатель от недопустимого. Например, предположим ,что программа выделяет массив символов...

char x[1024];

...а также указатель на некоторое место в этом массиве, например,

char *y = &x[107];

Можно ли увеличивать y для доступа к последующим элементам?

Если x представляет собой строковый буфер, может быть да.
Если x представляет собой сетевое сообщение, может быть нет.

 Жизнь еще сложнее, если программа использует соединения (объединения).

union u{
    int i;
    struct s{
        int j;
        int k;
    };
};
int *ptr = &(u.s.k); //Указывает ли это на правильные данные?

Проблема в том, что в C указатель не кодирует информацию о предполагаемой семантике (смысле) этого указателя. Таким образом, большинство инструментов на пытаются угадать те семантики (смыслы). Вместо этого инструменты имеют менее высокую (возвышенную) цель,чем "абсолютно правильная" семантика указателя: инструменты просто применяют границы (ограничения) памяти для объектов кучи и объектов стеков. Целью высокого уровня является: для указателя p', полученного из p, p' следует разыменовывать только для получения доступа к допустимой области памяти, принадлежащей p.

Закрепление границ памяти - более слабая цель ,чем применение "абсолютно правильной" семантики указателя. Программы могут все еще "выстрелить себе в ногу", наносы вред своей памяти неприятными способами (например, в примере объединения приложение может писать в ptr, даже если она не определена).

Однако, проверка границ все еще полезна, потому что предотвращает *произвольную* перезапись памяти. Программа может только подавить свою память, если эта память действительно выделена! ЭТО СЧИТАЕТСЯ ПРОГРЕССОМ В МИРЕ С.
Недостатком проверки границ является то, что это требует изменений в компиляторе, и программы должны быть перекомпилировны (пересобраны) с помощью нового компилятора. Это становится проблемой, если у вас есть доступ только к бинарным файлам.

Какие существуют подходы к реализации проверки границ?

Подход #1: Electric fences

Это старый подход, основным достоинством которого была простота.
Идея: Выровняйте каждый объект множества с защищенной страницей и используйте таблицы страниц, чтобы гарантировать, что обращения к защищенной странице вызовут исключение (ошибку).

+---------+
Защита 
|
|         |  ^
+---------+  | Переполнение вызывает исключение
| объект
  кучи   |  |
+---------+

Это удобный способ отладки, так как переполнение кучи немедленно приведет к сбою (крашу), а не к молчаливому повреждению кучи и причине непредвиденного сбоя в будущем.
Большое преимущество: Работает без исходного кода---не надо изменять компилято или пересобирать (перекомпилировать) программу! [Вам *нужно* повторно связать (перелинковать) их, чтобы они использовали новую версию malloc, в которой реализованы Electric fences]

Большой недостаток: Огромные накладные расходы! На странице есть всего один объект и вы имеете накладные расходы на фиктивную (подставную) страницу, которая не используется для "реальных" данных.

Резюме: Electric fences могут быть полезны в качестве методов отладки и они могут предотвратить некоторые виды переполнения буфера для объектов кучи.Однако, electric fences не может защитить стек и накладные расходы памяти слишком велики для использования в готовых системах.

Подход #2: толстый указатель (fat pointer)
Идея: Изменить представление указателя, чтобы добавить информацию о границах. Сейчас указатель включает адрес памяти и информацию о границах объекта, который находится в этом регионе памяти.
Например:
Обычный 32-bit указатель  
+-----------------+
| 4-byte address  |
+
-----------------+
Толстый указатель (96 bits)
+-----------------+----------------+---------------------+
| 4-byte obj_base | 4-byte obj_end | 4-byte curr_address |
+-----------------+----------------+---------------------+

Вам необходимо изменить компилятор и пересобрать (перекомпилировать) программы для того, чтобы использовать толстые указатели. Компилятор генерирует код для прерывания программы если она разыменовывает указатель, адрес которого находится за пределами его собственной базы ... конечный диапазон.

int *ptr = malloc(sizeof(int) * 2);
while(1){
    *ptr = 42;                   <----------|
     ptr++;                                   |
}                                                |
    __________________________|
    |

Этот код проверяет текущий адрес указателя и гарантирует, что он находится в допустимых пределах. Таким образом, этот код не будет выполняться на третьей итерации цикла.

Проблема #1: Может быть дорого проверять все разыменовывания указателей. Сообщество C ненавидит дорогостоящие операции, потому что C - это СКОРОСТЬ, СКОРОСТЬ, СКОРОСТЬ.
Проблема #2: Толстые указатели несовместимы с большинством существующего программного обеспечения.
Вы не можете передать толстый указатель на не измененную библиотеку.
Вы не можете использовать толстые указатели в структурах данных фиксированного размера. Например, sizeof(that_struct) изменится!

Обновления толстых указателей не атомарны, потому что они охватывают несколько слов. Некоторые программы предполагают ,что записи указателей являются атомарными.

Подход #3: Используйте теневые структуры данных для отслеживания информации о границах (Джонс и Келли, Baggy).

Основная идея: Для каждого размещенного объекта укажите, насколько объект велик. Например: Записать значение переданное malloc: char *p = malloc(mem_size);
Для статических переменных значения определяются компилятором:
char p[256];

Для каждого указателя нам необходимо вмешаться в две операции:
- арифметика указателя: char *q = p + 256;
- разыменовывание указателя: char ch = *q;

Вопрос: Почему нам надо вмешиваться в разыменовывание? Разве мы не можем сделать только арифметику?
Ответ: Недопустимый указатель не всегда является ошибкой! Например, указатель на элемент за последним элементом массива может быть использован в качестве остановки в цикле. Приложения могут также делать такие глупые вещи как:
- моделирование 1-индексных массивов
- вычисление p+(a-b) как (p+a)-b
- создание указателей, которые выходят за допустимые границы

Таким образом, простое создание недопустимого указателя не должно приводить к сбою программы.

Вопрос: Почему нам надо вмешиваться в арифметику? Разве мы не можем сделать только разыменовывание?
Ответ:  Вмешательство в арифметику - это то, что позволяет нам отслеживать происхождение указателей и устанавливать OOB ((out-of-bound)граничный) бит. Без этого мы не сможем определить когда производный указатель выйдет за границы своего базового объекта.

Проблема #1: Как мы можем найти информацию о границах для обычного указателя, т.е. указателя, который находится в границах?
Наивно (Просто): Использовать хэш-таблицу или дерево интервалов для сопоставления адресов с границами.
Плюс: Эффективное пространство (хранить информацию только об используемых указателях, не все возможные адреса)
Минус: Медленный поиск (множественный доступ к памяти для каждого поиска).


Наивно (Просто): Использовать массив для хранения информации о границах для "каждого" адреса памяти.
Плюс: Быстро!
Минус: Действительно большие накладные расходы по памяти.

Проблема #2: Как мы заставляем разыменовывать указатели за границами для сбоя?

Наивно (Просто): Инструмент разыменовывает каждый указатель.
Плюс: Ох, это работает!
Минус: Дорого---мы должны выполнить дополнительный код для каждого разыменовывания!

Подход с расширенными (мешковатыми) границами: 5 трюков
Округлите каждое выделение места к степени двойки и приравняйте его начало к этой степени двойки.
Выразите каждый предел диапазона как log_2(размер_выделенного_места). Для 32х-битных указателей надо только 5 бит для описания возможного диапазона.
Хранить информацию о лимите в линейном массиве: быстрый поиск с одним байтом на запись. Также вы можете использовать виртуальную память для выделения массива по требованию!

Выделение памяти с разбивкой по сегментам (например, 16 байтов): меньшее количество записей в массиве.
Например:
slot_size = 16
p = malloc(16); 
table[p/slot_size] = 4;
p = malloc(32); 
table[p/slot_size] = 5;
table[(p/slot_size) + 1] = 5;

Теперь, учитывая известный хороший указатель p и производный указатель p', мы можем проверить действителен ли p', посмотрев имеют ли оба указателя одинаковый префикс в своих адресных битах, и отличаются они только в своих младших битах e, где e равно логарифму размера выделенного места.
Код C
------

p' = p + i;

Проверка границ
------------
size = 1 << table[p >> log_of_slot_size]; base = p & ~(size - 1);

(p' >= base) && ((p' - base) < size)

Оптимизированная проверка границ
----------------------

(p^p') >> table[p >> log_of_slot_size] == 0

Использовать систему виртуальной памяти для предотвращения выхода за границы привязки (разыменовывания??): установить самый старший бит в граничном (ООВ) указателе, а затем пометить страницы в верхней половине адресного пространства как недоступные. Таким образом нам пока не нужен инструмент для разыменовывания указателей для предотвращения плохих обращений к памяти!
Пример кода (предположим, что slot_size=16):
char *p = malloc(44);

//Обратите внимание, что выделяется ближайшая степень 2 (т.е., 
//64 байта). Итак, есть 
//64/(slot_size) = 4 записи ограничивающей таблицы
//для которых установлено значение log_2(64) = 6.

char *q = p + 60;
//Это нормальный доступ: размер прошлого 
//объекта р равен 44, но все еще в расширенных
//границах равных 64.

char *r = q + 16;

//r в настоящее время смещен на 60+16=76 от
//p. это значит что r на (76-64)=12 байт
//за пределами p. Это больше чем
//половина отрезка, поэтому расширенные границы
//вызовут ошибку.

char *s = q + 8;
//s в настоящее время смещена на 60+8=68 от p.
//Таким образом, s находится всего в 4 байтах за расширенными 
//границами, что составляет менее половины отрезка. 
//Исключение не будет вызвано, но граничный (OOB) 
//старший бит установлен в s, так что s 
//не может быть разыменована.

char *t = s - 32;
//t теперь возвращается в пределы, поэтому
//граничный бит очищается.

Для граничных указателей устанавливается старший бит (если граница в пределах половины отрезка)

Как правило, ядро ОС живет в верхней половине и защищает себя с помощью аппаратных средств страничной организации.
Вопрос: Почему половина отрезка для выхода за границы?

Итак, какой ответ на домашнюю задачу?
char *p = malloc(256); char *q = p + 256;

char ch = *q; //Вызовет ли это ошибку?

//Подсказка: Насколько велики расширенные границы для p?

Дополнительная информация

===============================
Некоторые ошибки в статье о расширенных границах:
Слайд (Рисунок) 3, явная проверка границ должна генерировать размер следующим образом:
size = 1 << table[p >> log_of_slot_size]

Слайд (Рисунок) 3, оптимизированная проверка границ должна быть

(p^p') >> table[p >> log_of_slot_size] == 0

Слайд (Рисунок) 5 и 18, арифметический код указателя должен быть
char *p = &buf[i];
или
char *p = buf + i;

MIT OpenCourseWare

http://ocw.mit.edu

6.858 Безопасность информационных систем

Осень 2014 года.

Для получения информации о размещении ссылок на наши материалы или о наших Правилах использования, посетите http://ocw.mit.edu/terms.

Внимание! Этот перевод, возможно, ещё не готов.
Его статус: идёт перевод

Переведено на Нотабеноиде
http://translate.kursomir.ru/book/5/9

Переводчики: Chantico


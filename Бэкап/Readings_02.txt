$\textbf{Грубая проверка границ (baggy bounds checking): эффективная защита от ошибок выхода за границы с обратной совместимостью.}$

Оригинал статьи находится по адресу http://research.microsoft.com/apps/pubs/default.aspx?id=101450

Периклис Акритидис$^*$, Мануэль Коста$^†$, Мигель Кастро$^†$, Стивен Хэнд$^*$

$^*$Компьютерная лаборатория Кэмбриджского университета, Великобритания
{pa280,smh22}@cl.cam.ac.uk

$^†$Кэмбриджская исследовательская лаборатория Microsoft, Великобритания
{manuelc,mcastro}@microsoft.com

$\textbf{Аннотация}$

Атаки, использующие ошибку выхода за границы в программах на C и C++ широко распространены, несмотря на многие годы исследований в области проверки границ.

Предыдущие методы проверки границ с обратной совместимостью, которые могли быть применены к программам на C и C++ без их модификации, содержали структуры данных с информацией о границах для каждого выделенного объекта и производили поиск в структуре данных для проверки, остаётся ли указатель внутри границ.

Структура данных могла вырастать до внушительных размеров и её использование становилось расточительным.

В этой публикации мы представляем метод проверки границ с обратной совместимостью, который в значительной степени снижает потерю производительности.

Ключевой момент в сжатии данных о размерах выделенных областей памяти и их привязке для эффективного поиска границ и, соответственно, эффективной проверки границ.

Наш метод приводит к невысокой потере производительности на практике - для сервера Apache пропускная способность снижается только на 8%. Он в 2 раза быстрее, чем самый быстрый из предыдущих методов и в 5 раз быстрее и использует меньше памяти, чем запись границ объектов в виде расширяющегося дерева.

$\textbf{1 Введение}$

Проверка границ в коде на C и C++ защищает от широкого диапазона уязвимостей.

Задача была в том, чтобы сделать проверку границ достаточно быстрой для промышленного использования и в то же время сохранить обратную совместимость с бинарными библиотеками для обеспечения инкрементного развёртывания.

Решения, использующие $\textit{толстые указатели}$ [24, 18] дополняют в представление указателя информацию о границах.

Это позволяет эффективно проверять границы, но препятствует обратной совместимости потому, что увеличение размера указателя изменяет расположение структур данных в памяти.

Методы проверки границ с обратной совместимостью [19, 30, 36, 15] используют отдельную структуру данных для поиска информации о границах.

Первые попытки приводили к сильному снижению производительности [19, 30, 36] (порядка 2x - 10x) так как поиск границ был расточительным и структура данных могла вырастать до больших размеров.

В более поздней работе [15] применяется сложный статический анализ указателя для уменьшения количества поисков границ; в связи с этим падение производительности снижается по тестам Olden bencmark в среднем на 12%.

[ЗДЕСЬ ВСТАВЛЯЕМ РИСУНОК 1] Рисунок 1: Выделяемая память, как правило, выравнивается по определённым границам, следовательно может быть больше, чем переданный размер объекта. Проверяя по границам выравнивания вместо границ объекта, мы разрешаем доступ к выравнивающему участку, но зато существенно снижаем затраты на определение границ во время выполнения.

В этой публикации мы представляем $\textit{метод грубой оценки границ}$ - метод проверки границ с обратной совместимостью, снижающий затраты на проверку границ.

Нам удалось достичь этого за счет использования $\textit{границ выделенного блока}$ вместо точных границ объекта, как показано на рисунке 1.

В связи с тем, что выделение памяти выравнивает выделяем блок по границам выравнивания, есть определённый класс неопасных ошибок нарушения границ объекта, которые остаются незамеченными при проверке выровненных границ.

Предыдущие работы [4,19,2] использовали это свойство различными способами.

Здесь мы применяем это для эффективной проверки границ с обратной совместимостью.

Мы используем бинарный buddy-алгоритм для того, чтобы представить границы выделенной памяти в компактном виде: так как все размеры выделенных блоков являются степенями двойки, для хранения двоичного логарифма размера выделенного блока достаточно одного байта.

Более того, нет необходимости хранить дополнительную информацию, потому что базовый адрес выделенного блока размера $\textit{s}$ может быть вычислен сбросом $\textit{log}_{2}\textit{(s)}$ младших значащих бит указателя в выделенный блок.

Это позволяет нам использовать для таблицы границ структуру данных, более эффективную по времени и размеру.

Мы используем непрерывный массив вместо более затратных структур данных (таких, как расширяющееся дерево, использовавшееся в предыдущих работах).

Ещё это предоставляет нам элегантный способ взаимодействия с указателями, временно выходящими за границы.

Более подробно мы опишем наш проект во втором разделе.

Мы реализовали $\textit{грубую проверку границ}$ как плагин компилятора для фреймворка генерации кода Microsoft Phoenix [22], наряду с дополнительными компонентами времени выполнения (раздел 3).

Плагин вставляет код проверки границ для всей арифметики указателей, для которой не может быть статически доказана безопасность, и размещает и выравнивает переменные в стеке, где это необходимо.

Компонент времени выполнения включает бинарный buddy-алгоритм для выделения памяти в куче и обработчик виртуальной памяти выделяемой пользователю для формирования таблицы границ при запросах.

В разделе 4 мы оценим производительность нашей системы с помощью Olden benchmark (сравнив её с алгоритмом Дурьяти и Адве [15]) и SPECINT 2000.

Мы сравним перерасход памяти с версией нашей системы, использующей реализацию расширяющегося дерева из [19, 30].

Также мы проверим эффективность предотвращения атак нашей системой, используя тестирование, описанное в [34] и запустим некоторое количество критичных к безопасности готовых коммерческих компонентов, чтобы подтвердить её применимость.

Раздел 5 описывает нашу модель и реализацию для 64-битных архитектур.

В этих архитектурах обычно имеются резервные биты в указателях. Мы опишем схему, использующую это для кодирования информации о границах напрямую в указателе вместо использования отдельной таблицы.

Наши сравнительные вычисления показывают, прирост производительности при использовании резервных бит для кодирования границ может оправдать дополнительные сложности. Таким образом, использование их непосредственно для кодирования информации необходимой для получения границ для указателей, выходящих за границы, может быть целесообразным.

Наконец, мы рассмотрим смежные работы (раздел 6), обсудим ограничения и перспективные возможности (раздел 7) и подведём итоги (раздел 8).

$\textbf{2 Модель}$
$\textbf{2.1 Грубая оценка границ}$
Наша система проверки границ с обратной совместимостью для C/C++ включается в общую архитектуру (рисунок 2).

Она конвертирует исходный код в некоторое промежуточное представление (ПП), находит потенциально небезопасные операции с арифметикой указателей и вставляет проверки для того, чтобы убедиться, что результат будет в пределах границ.

Далее компонует сгенерированный код с нашей библиотекой времени выполнения и бинарными библиотеками, скомпилированными с проверками либо без них, для создания защищенного исполняемого файла.

[ЗДЕСЬ ВСТАВЛЯЕМ РИСУНОК 2] Рисунок 2: Общая архитектура системы. Наш вклад выделен пунктиром.

Мы использовали для проверки границ метод $\textit{определяемого объекта}$, представленный Джонсом и Келли [19].

Получив указатель на объект внутри границ, этот подход гарантирует, что любой производный указатель будет указывать на тот же объект.

Информация о границах для каждого объекта записывается в таблицу границ.

Эта таблица обновляется при выделении памяти под объект и её освобождении: для объектов в куче это делается при вызове функций семейства  $\texttt{malloc}$; для объектов в стеке на входе и выходе из функции; для глобальных объектов при старте программы.

Метод определяемого объекта производит проверку границ при арифметике указателей.

Он использует исходный указатель для поиска границ в таблице, производит операцию и проверяет, остаётся ли конечный указатель в границах.

Если конечный указатель не указывает на тот же объект, мы маркируем его, как выходящий за границы, для предотвращения разыменования (как в [30, 15]).

Несмотря на это, мы допускаем его использование в дальнейшей арифметике указателей, так как в результате может получится указатель, находящийся в границах.

Механизм маркировки описан подробнее в разделе 2.4.

Грубая проверка границ использует очень компактное представление информации о границах.

Предыдущие методы хранили в таблице границ указатель на начало объекта и его размер, что требовало не менее 8 байт.

Так как у нас выделяемая объектам память привязана к степеням двойки, то можно использовать границы выделенной области вместо границ объекта.

Это позволяет нам использовать один байт для кодирования информации о границах.

В таблице размеров мы храним двоичный логарифм от размера выделенного блока:
$\texttt{e=log2(size);}$
Имея эту информацию, мы можем восстановить размер выделенного блока и указатель на его начало:
$\texttt{size = 1 << e;}$
$\texttt{base = p & ~(size - 1);}$
Для преобразования из указателя в границах в указатель на объект нам необходима $\textit{таблица границ}$.

Предыдущие решения, основанные на методе определяемого объекта (такие, как [19, 30, 15]) реализовывали таблицу границ с использованием расширяющегося дерева.

Грубая проверка в отличии от них реализует таблицу границ с использование непрерывного массива.

Таблица невелика, так как каждая запись занимает всего один байт.

Кроме того, мы разбиваем память на выровненные $\textit{слоты}$ размером $\textit{slot_size}$ байт.

Таблица границ имеет одну запись на слот, вместо одной записи на байт.

Таким образом, перерасход памяти на таблицу составит 1/$\textit{slot_size}$, и мы можем настраивать параметр $\textit{slot_size}$ для балансировки расхода памяти между дисперсностью и размером таблицы.

Мы выравниваем объекты по границам слотов для того, чтобы быть уверенными, что два объекта не будут находиться в одном слоте.

Доступ к таблице достаточно быстрый.

Для получения указателя на запись, соответствующую адресу, мы побитово сдвигаем адрес вправо на константу $\textit{log2(slot_size)}$ и прибавляем константный указатель на начало таблицы.

Мы можем использовать этот указатель для получения информации о границах за одно обращение к памяти, вместо обхода расширяющегося дерева (как в предыдущих решениях).

Отметим, что грубая проверка границ разрешает неопасный доступ с выходом за границы к области памяти между объектом и границей выравнивания.

Это не нарушает безопасность, так как при этом нельзя прочитать или записать в другой объект.

Это не может быть использовано для обычных атак таких, как ($\textit{a}$) перезапись адреса возврата, указателя на функцию или иных критичных для безопасности данных; или ($\textit{b}$) чтение значимой информации, такой как пароль, из другого объекта.

Также мы защищены от менее распространённых атак, при которых программ читает значения из области между объектом и границей блока, оставшиеся от удалённого объекта, занимавшего эту память.

Мы предотвращаем эту атаку очищая эту область памяти при выделении.

$\textbf{2.2 Эффективные проверки}$
В общем, проверка границ указателя $\texttt{p'}$, полученного в результате арифметики указателей с указателем $\texttt{p}$, использует два сравнения: для нижней и для верхней границы, как показано на рисунке 3.

[ЗДЕСЬ ВСТАВЛЯЕМ РИСУНОК 3] Рисунок 3: грубая проверка границ включает оптимизированную проверку границ: мы можем проверить, находится ли в границах указатель $\texttt{p'}$, полученный из указателя $\texttt{p}$, просто проверив, что $\texttt{p}$ и $\texttt{p'}$ имеют одинаковый префикс и отличаются только $\texttt{e}$ младшими значащими битами, где $\texttt{e}$ - двоичный логарифм размера выделенного блока.

Мы разработали оптимизированную проверку границ, в которой даже нет необходимости вычислять нижнюю и верхнюю границы.

Она использует значение $\texttt{p}$ и значение двоичного логарифма размера выделенного блока, $\texttt{e}$, полученное из таблицы границ.

Ограничения по размеру блока и выравниванию гарантируют, что $\texttt{p'}$ в границах выделенного блока, если отличается от $\texttt{p}$ только в  $\texttt{e}$ младших значащих битах.

Это позволяет нам сдвинуть $\texttt{p^p'}$ на $\texttt{e}$ и проверить, будет ли результат равен 0, как это показано на рисунке 3.

Более того, для указателей $\texttt{p'}$, у которых $\texttt{sizeof(*p') > 1}$, мы также должны проверить, что $\texttt{(char *) p' + sizeof(*p') - 1}$ также находится в границах для предотвращения доступа к информации за границами через доступ к подпоследовательности $\texttt{*p'}$.

Грубая проверка границ может избежать этой дополнительной проверки, если $\texttt{p'}$ указывает на базовый тип данных.

Доступ к этим типам данных не может пересечь границу выделенного блока, так как их размер является степенью двойки и меньше $\textit{slot_size}$.

При проверке указателей на структуры, не удовлетворяющие этим ограничениям, мы производим обе проверки.

$\textbf{2.3 Совместимость}$
Грубая проверка границ работает даже тогда, когда инструментированный код скомпонован с неинструментированными библиотеками.

Код библиотеки работает без изменений, так как там не производится проверок, но необходимо убедиться, что инструментированный код работает при обращении к памяти, выделенной неинструментированной библиотекой.

Это важный вопрос совместимости, так как некоторые библиотеки распространяются в бинарном виде.

Мы достигли совместимости, используя двоичный логарифм от максимального выделенного размера как значение по умолчанию для записей в таблице границ.

Инструментированный код при выделении перезаписывает значение по умолчанию логарифмом размера выделения и восстанавливает значение по умолчанию при освобождении.

Это гарантирует, что записи для объектов, выделенных неинструментируемой библиотекой, унаследуют значение по умолчанию.

Следовательно, инструментированный код может производить проверки как обычно при доступе к памяти, но эти проверки будут неэффективны.

Мы можем перехватывать выделение памяти в куче кодом библиотеки на этапе компоновки, используя buddy-алгоритм для осуществления проверок границ при доступе к памяти, выделенной библиотекой, но в текущей версии это не производится.

$\textbf{2.4 Поддержка указателей, выходящих за границы}$
Указатель в C может указывать за пределы объекта вполне легально.

Для таких указателей не производится разыменование, но они могут использоваться в сравнениях и в арифметике указателей, в результате которой получится корректный указатель, и уже он может быть разыменован программой.

Выходящий за границы указатель представляет проблему для метода определяемого объекта, так как он полагается на указатель в границах для получения границ объекта.

Стандарт языка C позволяет использовать указатели выходящие за границы на один элемент после и перед массивом.

Джонс и Келли [19] поддерживают эти легальные указатели, выходящие за границы, дополняя объект с обоих сторон одним байтом.

Мы не используем эту технику, так как она плохо взаимодействует с нашими условиями выделения памяти: добавление одного байта может увеличить размер выделенной памяти вдвое в случае, когда запрошенный размер памяти является степенью двойки.

Многие программы нарушают стандарты C и генерируют некорректные указатели, сильно выходящие за границы, хотя никогда их не разыменовывают.

Например - использование ложного отсчета с единицы в массиве путём уменьшения указателя, возвращаемого $\texttt{malloc}$, и прочая безвкусица.

CRED [30] улучшили проверку границ Джонса и Келли [19], отслеживая такие указатели с использованием другой вспомогательной структуры данных.

Мы не используем этот подход, так как он вызывает дополнительный перерасход при удалении локальных объектов и объектов в куче: когда объект удаляется, необходимо производить поиск по вспомогательной структуре данных и удалять записи, отслеживающие указатели объекта, выходящие за границы.

Плюс к этому, записи во вспомогательной структуре данных могут накапливаться до тех пор, пока соответствующий объект не будет удалён.

[ЗДЕСЬ ВСТАВЛЯЕМ РИСУНОК 4] Рисунок 4: Мы можем определить, когда указатель выходит за границы на $textit{slot_size}$/2 выше или ниже выделенного блока памяти. Это даёт нам возможность корректно получить указатель на объект добавляя или вычитая $textit{slot_size}$.

Мы обрабатываем указатели, выходящие за границы на $textit{slot_size}$/2 байт от оригинального объекта, следующим образом.

Вначале маркируем выходящий за границы указатель, чтобы предотвратить его разыменование (как в [15]).

Мы используем аппаратную защиту памяти для предотвращения разыменования, устанавливая старший значащий бит указателя и ограничивая программу нижней половиной адресного пространства (что зачастую является областью пользовательских программ).

Мы можем восстановить оригинальный указатель, снимая этот бит.

Далее нам необходимо восстановить указатель на объект из указателя за границами без использования дополнительной структуры данных.

Внимание! Этот перевод, возможно, ещё не готов.
Его статус: идёт перевод

Переведено на Нотабеноиде
http://translate.kursomir.ru/book/5/539

Переводчики: mummick


1
00:00:00,000 --> 00:00:00,050


2
00:00:00,050 --> 00:00:01,770
Материалы этой
лекции предоставлены

3
00:00:01,770 --> 00:00:04,010
под лицензией
Creative Commons.

4
00:00:04,010 --> 00:00:06,860
Ваша поддержка помогает
платформе МТИ OpenCourseWare

5
00:00:06,860 --> 00:00:10,720
предоставлять высококачественные
образовательные материалы бесплатно.

6
00:00:10,720 --> 00:00:13,330
Поддержать нас материально и
ознакомиться с остальными

7
00:00:13,330 --> 00:00:17,207
курсами МИТ, вы можете, посетив
веб-сайт МИТ OpenCourseWare,

8
00:00:17,207 --> 00:00:17,832
расположенный по адресу ocw.mit.edu

9
00:00:17,832 --> 00:00:22,730


10
00:00:22,730 --> 00:00:23,390
ПРОФЕССОР: Здравствуйте.

11
00:00:23,390 --> 00:00:24,750
Меня зовут Срини Девадас.

12
00:00:24,750 --> 00:00:27,040
Я профессор электротехники
и информатики.

13
00:00:27,040 --> 00:00:27,650
Я профессор электротехники
и информатики.

14
00:00:27,650 --> 00:00:30,970
В этом семестре, я, вместе с
профессором Эриком Дeмейном

15
00:00:30,970 --> 00:00:34,950
буду читать курс лекций "6.006 -
Введение в теорию алгоритмов".

16
00:00:34,950 --> 00:00:36,001
Эрик, скажите "Привет".

17
00:00:36,001 --> 00:00:36,883
ЭРИК ДЕМЕЙН: Привет.

18
00:00:36,883 --> 00:00:38,650
[СМЕХ В АУДИТОРИИ]

19
00:00:38,650 --> 00:00:40,210
ПРОФЕССОР: И мы
надеемся, что вам

20
00:00:40,210 --> 00:00:43,710
понравится курс
и понравится изучать

21
00:00:43,710 --> 00:00:45,760
различные алгоритмы
в этом курсе.

22
00:00:45,760 --> 00:00:50,760
Итак, наш план на сегодня
таков: сперва я очень быстро

23
00:00:50,760 --> 00:00:55,004
пройдусь по
организационным моментам.

24
00:00:55,004 --> 00:00:56,420
Для начала, я бы хотел
сказать, что вы можете

25
00:00:56,420 --> 00:01:00,670
зайти на этот веб-сайт, который
указан на доске, вот здесь.
[http://courses.csail.mit.edu/6.006/]

26
00:01:00,670 --> 00:01:02,250
Там содержится вся
необходимая информация.

27
00:01:02,250 --> 00:01:06,430
О чем этот курс,
программа курса,

28
00:01:06,430 --> 00:01:11,590
что ожидается от вас,
расписание домашних заданий,

29
00:01:11,590 --> 00:01:15,660
расписание контрольных
и много чего еще.

30
00:01:15,660 --> 00:01:19,460
Далее я перейду непосредственно
к курсу и расскажу

31
00:01:19,460 --> 00:01:24,550
о таких интересных вещах,
как алгоритмы и их сложность.

32
00:01:24,550 --> 00:01:26,490
Затем я хотел бы немного
рассказать вам о том,

33
00:01:26,490 --> 00:01:29,380
что мы будем изучать
в этом курсе.

34
00:01:29,380 --> 00:01:31,640
И после этого мы перейдем
к сегодняшней лекции,

35
00:01:31,640 --> 00:01:35,230
в которой разберем задачу
поиска локального максимума.

36
00:01:35,230 --> 00:01:38,360
Мы рассмотрим две ее версии -
для одномерного случая

37
00:01:38,360 --> 00:01:41,900
и двумерного, а также
алгоритмы для каждого случая,

38
00:01:41,900 --> 00:01:46,670
с помощью которых
решается эта задача.

39
00:01:46,670 --> 00:01:50,000
Вы увидите, что есть
ощутимая разница

40
00:01:50,000 --> 00:01:53,090
между этими
алгоритмами,

41
00:01:53,090 --> 00:01:56,480
когда мы оценим
их сложность.

42
00:01:56,480 --> 00:01:59,070
Под сложностью я имею
в виду то, что алгоритмы

43
00:01:59,070 --> 00:02:02,750
тратят разное время на
свою работу в зависимости

44
00:02:02,750 --> 00:02:06,210
от размера входных данных.
И это время зависит от того,

45
00:02:06,210 --> 00:02:08,600
насколько эффективны
эти алгоритмы.

46
00:02:08,600 --> 00:02:14,370
Перед нашим курсом вы
должны были прослушать курс

47
00:02:14,370 --> 00:02:18,620
6.042, в котором вам рассказывали
об асимптотической сложности.

48
00:02:18,620 --> 00:02:21,240
И в этой лекции мы
проанализируем

49
00:02:21,240 --> 00:02:25,430
относительно простые
алгоритмы в терминах

50
00:02:25,430 --> 00:02:28,070
их асимптотической сложности.

51
00:02:28,070 --> 00:02:30,340
Вы сможете
сравнить их и сказать,

52
00:02:30,340 --> 00:02:33,940
что этот алгоритм быстрее
этого - предполагая то, что

53
00:02:33,940 --> 00:02:37,320
размер входных данных
очень велик. И это так, потому

54
00:02:37,320 --> 00:02:40,840
что у первого алгоритма
асимптотическая сложность меньше.

55
00:02:40,840 --> 00:02:43,185
Итак, давайте теперь
поговорим о курсе.

56
00:02:43,185 --> 00:02:52,420


57
00:02:52,420 --> 00:02:54,550
В двух словах этот курс
о том, как разрабатывать

58
00:02:54,550 --> 00:02:58,910
эффективные процедуры
для решения задач,

59
00:02:58,910 --> 00:03:04,850
у которых на вход
подается много данных.

60
00:03:04,850 --> 00:03:06,800
Когда я говорю
"много данных",

61
00:03:06,800 --> 00:03:10,720
я имею в виду такие вещи,
как карту всех крупных

62
00:03:10,720 --> 00:03:14,110
дорог в США; геном
человека, который включает

63
00:03:14,110 --> 00:03:17,850
миллиард букв из
некоторого алфавита;

64
00:03:17,850 --> 00:03:23,170
социальную сеть, размером
с Facebook, в которой, я думаю,

65
00:03:23,170 --> 00:03:26,840
около 500
миллионов узлов.

66
00:03:26,840 --> 00:03:28,280
Такие вещи я имею в виду,
когда говорю "много данных".

67
00:03:28,280 --> 00:03:31,470
Нужно понимать, что наше определение
для слова "много" меняется

68
00:03:31,470 --> 00:03:35,440
меняется со временем.
В 21 веке "много" - это,

69
00:03:35,440 --> 00:03:36,971
приблизительно, триллион.

70
00:03:36,971 --> 00:03:37,470
Да?

71
00:03:37,470 --> 00:03:40,680
Когда я был в вашем возрасте,
"много" равнялось, где-то, тысяче.

72
00:03:40,680 --> 00:03:42,400
[СМЕХ В АУДИТОРИИ]

73
00:03:42,400 --> 00:03:44,844
Я подозреваю, что я постарел.

74
00:03:44,844 --> 00:03:46,760
Когда Эрик был вашего возраста,
"много" было миллионом.

75
00:03:46,760 --> 00:03:47,260
Верно?

76
00:03:47,260 --> 00:03:48,650
[СМЕХ В АУДИТОРИИ]

77
00:03:48,650 --> 00:03:55,000
Важно то, что мир стремительно
движется вперед,

78
00:03:55,000 --> 00:03:56,420
вещи становятся больше.

79
00:03:56,420 --> 00:04:00,880
Мы можем производить вычисления
на огромных объемах данных,

80
00:04:00,880 --> 00:04:03,220
но это не означает того,
что эффективность не имеет

81
00:04:03,220 --> 00:04:05,760
первостепенного значения.

82
00:04:05,760 --> 00:04:08,690
К примеру, вы
можете просмотреть

83
00:04:08,690 --> 00:04:13,550
миллиард элементов
за считанные секунды.

84
00:04:13,550 --> 00:04:17,750
Но если вы используете
алгоритм с кубической сложностью,

85
00:04:17,750 --> 00:04:19,899
то обнаруживаете, что необходимо
просмотреть не 10 в 9 степени

86
00:04:19,899 --> 00:04:22,079
элементов, а 10 в 27 степени.

87
00:04:22,079 --> 00:04:24,510
Даже современные компьютеры
не могут справиться

88
00:04:24,510 --> 00:04:30,890
с такими числами. Поэтому важно
беспокоиться об эффективности.

89
00:04:30,890 --> 00:04:34,820
И с ростом размера входных данных,
беспокоиться нужно все больше.

90
00:04:34,820 --> 00:04:35,320
Это ясно?

91
00:04:35,320 --> 00:04:39,398
Таким образом, в этом
курсе мы будем искать

92
00:04:39,398 --> 00:04:43,760


93
00:04:43,760 --> 00:04:51,310
эффективные процедуры для
решения задач большого масштаба.

94
00:04:51,310 --> 00:04:51,940
эффективные процедуры для
решения задач большого масштаба.

95
00:04:51,940 --> 00:04:58,140


96
00:04:58,140 --> 00:05:01,640
Также для нас важна
масштабируемость.

97
00:05:01,640 --> 00:05:07,030
Потому что, как вы знаете,
несколько десятилетий назад

98
00:05:07,030 --> 00:05:09,600
одна тысяча представлялась
большим числом,

99
00:05:09,600 --> 00:05:12,140
а сейчас это довольно
маленькое число.

100
00:05:12,140 --> 00:05:16,430
Возможно, что, к тому времени,
когда вы станете профессорами

101
00:05:16,430 --> 00:05:18,220
и будете читать лекции этого
курса в каком-нибудь университете,

102
00:05:18,220 --> 00:05:20,690
один триллион будет считаться
достаточно маленьким числом.

103
00:05:20,690 --> 00:05:24,430
И мы будем говорить о,
даже не знаю,

104
00:05:24,430 --> 00:05:27,520
числах порядка
10 в 18 степени,

105
00:05:27,520 --> 00:05:32,620
как о каком-то базовом
случае размера входных

106
00:05:32,620 --> 00:05:34,510
данных нашего алгоритма.

107
00:05:34,510 --> 00:05:38,120
Именно поэтому важно не
забывать о масштабируемости.

108
00:05:38,120 --> 00:05:41,480
Еще мы хотим иметь возможность
следить за тем, как наши алгоритмы

109
00:05:41,480 --> 00:05:44,000
ведут себя при увеличении размера
данных, поступающих на вход.

110
00:05:44,000 --> 00:05:47,210


111
00:05:47,210 --> 00:05:52,180
По ходу курса вы изучите несколько
различных структур данных,

112
00:05:52,180 --> 00:05:56,650
которые мы называем классическими
структурами данных.

113
00:05:56,650 --> 00:06:01,450
Двоичные деревья поиска,
хэш-таблицы, которые называют

114
00:06:01,450 --> 00:06:06,020
словарями в языке Python
и такие структуры,

115
00:06:06,020 --> 00:06:09,470
как сбалансированные
двоичные деревья поиска,

116
00:06:09,470 --> 00:06:12,975
которые более эффективны, чем
обычные двоичные деревья поиска.

117
00:06:12,975 --> 00:06:14,350
Все эти структуры данных
были придуманы

118
00:06:14,350 --> 00:06:18,540
не одно десятилетие назад.

119
00:06:18,540 --> 00:06:20,850
Можно сказать, что они
прошли проверку временем

120
00:06:20,850 --> 00:06:23,530
так как остаются полезными
и сегодня. Мы рассмотрим

121
00:06:23,530 --> 00:06:26,210
различные усовершенствования этих
структур данных, которые

122
00:06:26,210 --> 00:06:30,330
делают их более эффективными
при решении определенных задач.

123
00:06:30,330 --> 00:06:33,980
В этом курсе вы практически
не будете проектировать алгоритмы,

124
00:06:33,980 --> 00:06:36,180
вы будете учиться
их анализировать

125
00:06:36,180 --> 00:06:38,335
и лишь немного коснётесь
проектирования.

126
00:06:38,335 --> 00:06:40,880


127
00:06:40,880 --> 00:06:46,060
Продолжением этого курса

128
00:06:46,060 --> 00:06:48,530
является "6.046 - Проектирование

129
00:06:48,530 --> 00:06:52,080
и анализ алгоритмов".
И там вы сможете

130
00:06:52,080 --> 00:06:57,180
научиться разрабатывать
алгоритмы.

131
00:06:57,180 --> 00:06:59,880
Но сначала вы должны изучить
классические структуры данных

132
00:06:59,880 --> 00:07:06,260
и классические алгоритмы,
связанные с этими структурами,

133
00:07:06,260 --> 00:07:12,470
такие как сортировки,
поиск соответствий и так далее.

134
00:07:12,470 --> 00:07:17,200
Еще один прекрасный момент
касательно этого курса

135
00:07:17,200 --> 00:07:21,800
состоит в том, что
вы сами реализуете

136
00:07:21,800 --> 00:07:25,130
все эти структуры данных
и алгоритмы, используя Python.

137
00:07:25,130 --> 00:07:28,220


138
00:07:28,220 --> 00:07:30,880
В частности, каждое
домашнее задание

139
00:07:30,880 --> 00:07:38,680
содержит в себе
теоретическую часть

140
00:07:38,680 --> 00:07:41,930
и практическую, где
вам нужно программировать.

141
00:07:41,930 --> 00:07:43,430
Надеюсь, это поможет
связать теорию с практикой.

142
00:07:43,430 --> 00:07:46,060
Те вещи, о которых мы
будем говорить на лекциях,

143
00:07:46,060 --> 00:07:51,200
весь материал,
будет тесно связан

144
00:07:51,200 --> 00:07:53,260
с теоретической частью
ваших домашних заданий.

145
00:07:53,260 --> 00:07:55,800
Вы будете программировать
алгоритмы, о которых мы будем

146
00:07:55,800 --> 00:07:58,680
говорить на лекциях,
улучшать их и запускать,

147
00:07:58,680 --> 00:08:03,180
чтобы понять, хорошо ли они работают
на входных данных большого размера.

148
00:08:03,180 --> 00:08:06,510


149
00:08:06,510 --> 00:08:09,530
Еще позвольте мне
немного рассказать

150
00:08:09,530 --> 00:08:11,462
о модулях курса
и домашних заданиях.

151
00:08:11,462 --> 00:08:12,920
Мы надеемся, что
домашние задания

152
00:08:12,920 --> 00:08:15,470
будут интересными и
понравятся вам.

153
00:08:15,470 --> 00:08:19,430
Когда я говорю интересными,
я не обещаю, что они будут легкими.

154
00:08:19,430 --> 00:08:22,656
Скорее они будут бросающими
вызов и полезными. Так что к концу

155
00:08:22,656 --> 00:08:24,280
курса вы почуствуете,
что узнали что-то новое

156
00:08:24,280 --> 00:08:26,870
и с пользой
провели время.

157
00:08:26,870 --> 00:08:28,580
Здесь все понятно, да?

158
00:08:28,580 --> 00:08:30,550
Итак, содержание
курса таково.

159
00:08:30,550 --> 00:08:37,350


160
00:08:37,350 --> 00:08:41,830
Курс состоит из
восьми модулей,

161
00:08:41,830 --> 00:08:44,490
по каждому из
которых, строго говоря,

162
00:08:44,490 --> 00:08:47,020
у вас будет
домашнее задание.

163
00:08:47,020 --> 00:08:51,950
Первый модуль мы назвали
"Алгоритмическое мышление".

164
00:08:51,950 --> 00:08:55,710


165
00:08:55,710 --> 00:08:59,130
И сегодня мы приступим
к его изучению.

166
00:08:59,130 --> 00:09:01,480
Как я уже упомянул
в начале лекции,

167
00:09:01,480 --> 00:09:02,790
мы рассмотрим задачу
поиска локального максимума.

168
00:09:02,790 --> 00:09:04,350
И после вам предстоит
выполнить домашнее

169
00:09:04,350 --> 00:09:07,960
задание, условие которого
вы также получите сегодня.

170
00:09:07,960 --> 00:09:12,320
В этом домашнем задании,
будут некоторые

171
00:09:12,320 --> 00:09:14,420
алгоритмы, о которых
я расскажу сегодня,

172
00:09:14,420 --> 00:09:17,090
реализованные на языке Python,

173
00:09:17,090 --> 00:09:20,190
Парочка из них будет
содержать ошибки.

174
00:09:20,190 --> 00:09:24,340
Вам предстоит проанализировать
сложность этих алгоритмов;

175
00:09:24,340 --> 00:09:27,380
выяснить, какие из них эффективны
и не содержат ошибок;

176
00:09:27,380 --> 00:09:29,760
и доказать это
для одного из них.

177
00:09:29,760 --> 00:09:30,260
Ясно, да?

178
00:09:30,260 --> 00:09:33,320
Вот примерно такие
домашние задания вас ждут.

179
00:09:33,320 --> 00:09:37,600
Большинство ваших
домашних заданий

180
00:09:37,600 --> 00:09:40,036
будут похожи
на это.

181
00:09:40,036 --> 00:09:40,750
Хорошо.

182
00:09:40,750 --> 00:09:44,810
Если сейчас вам
что-то не ясно,

183
00:09:44,810 --> 00:09:46,690
не переживайте. Вы
поймете, о чем я говорю

184
00:09:46,690 --> 00:09:48,930
ближе к концу лекции,
когда прослушаете

185
00:09:48,930 --> 00:09:52,850
материал и увидите ваше
первое домашнее задание.

186
00:09:52,850 --> 00:09:57,540
У нас будет модуль, посвященный
сортировкам и деревьям.

187
00:09:57,540 --> 00:10:00,619
Сортировать мы будем
некоторые числа

188
00:10:00,619 --> 00:10:02,160
Представьте, что у вас
есть триллион чисел.

189
00:10:02,160 --> 00:10:04,250
И вы хотите отсортировать их.

190
00:10:04,250 --> 00:10:07,610
Какой алгоритм вы будете
использовать для этого?

191
00:10:07,610 --> 00:10:10,280
Деревья - это замечательная
структура данных.

192
00:10:10,280 --> 00:10:14,760
Существуют их различные вариации,
наиболее известная - двоичные деревья.

193
00:10:14,760 --> 00:10:17,580
И существует много способов
делать такие вещи, как

194
00:10:17,580 --> 00:10:22,560
планирование или, например,
сортировка, используя разные

195
00:10:22,560 --> 00:10:24,200
виды деревьев,
включая двоичные.

196
00:10:24,200 --> 00:10:31,330
И у нас будет домашнее
заданее, в котором вы,

197
00:10:31,330 --> 00:10:36,660
используя определенный
алгоритм сортировки, сделаете

198
00:10:36,660 --> 00:10:38,340
симулятор логической сети.

199
00:10:38,340 --> 00:10:41,150
Это будет вашим вторым домашним заданием.

200
00:10:41,150 --> 00:10:47,190
Еще есть модуль,
посвященный хэшированию,

201
00:10:47,190 --> 00:10:51,240
в котором, мы будем делать
такие штуки, как сравнение

202
00:10:51,240 --> 00:10:56,330
геномов. В прошлых семестрах мы
сравнивали геном человека с геномом

203
00:10:56,330 --> 00:10:59,350
крысы и обнаружили, что
эти геномы совпадают

204
00:10:59,350 --> 00:11:01,860
на 99%, что само по
себе удивительно.

205
00:11:01,860 --> 00:11:04,960
Еще раз повторюсь: эти
геномы настолько большие,

206
00:11:04,960 --> 00:11:07,590
что для того, чтобы сравнить
их и решить эту задачу,

207
00:11:07,590 --> 00:11:08,460
вам нужен действительно
эффективный метод сравнения.

208
00:11:08,460 --> 00:11:11,690
Если вы не сможете снизить сложность
алгоритма до приемлемой,

209
00:11:11,690 --> 00:11:15,300
вы не сможете решить эту
задачу, так как ваша

210
00:11:15,300 --> 00:11:19,950
программа просто не успеет
сделать это до того,

211
00:11:19,950 --> 00:11:21,260
когда домашнее
задание нужно будет сдать.

212
00:11:21,260 --> 00:11:21,760
Понятно, да?

213
00:11:21,760 --> 00:11:24,660
И это то, о чем не стоит забывать,

214
00:11:24,660 --> 00:11:28,860
когда вы будете тестировать
ваш код. Будьте уверены:

215
00:11:28,860 --> 00:11:32,140
когда вы запустите вашу программу,
на вход придет много данных.

216
00:11:32,140 --> 00:11:34,960
Вы должны постоянно оценивать
сложность вашего алгоритма.

217
00:11:34,960 --> 00:11:40,070
Особенно в те моменты, когда
вы придумываете псевдокод

218
00:11:40,070 --> 00:11:43,624
или программируете 
сам алгоритм.

219
00:11:43,624 --> 00:11:44,790
Еще мы поговорим о числах.

220
00:11:44,790 --> 00:11:47,420


221
00:11:47,420 --> 00:11:50,840
Много времени мы будем
говорить о больших числах.

222
00:11:50,840 --> 00:11:54,290
Настолько больших, что для их

223
00:11:54,290 --> 00:11:57,130
представления в компьютере
не хватит 32 или 64 битов.

224
00:11:57,130 --> 00:11:58,910
Эти числа имеют тысячи
бит в двоичном представлении.

225
00:11:58,910 --> 00:12:01,110
Хороший пример это
RSA шифрование,

226
00:12:01,110 --> 00:12:05,140
которое используется
в протоколе SSL.

227
00:12:05,140 --> 00:12:09,720
Когда вы открываете
веб-сайт по HTTPS, вы на

228
00:12:09,720 --> 00:12:12,710
самом деле используете RSA.

229
00:12:12,710 --> 00:12:15,360
И как правило, алгоритм RSA
использует простые

230
00:12:15,360 --> 00:12:18,510
числа длиной
несколько тысяч бит.

231
00:12:18,510 --> 00:12:19,930
Возникает вопрос: как
обработать такие чилса?

232
00:12:19,930 --> 00:12:21,270
Как обрабатывает такие
числа язык Python?

233
00:12:21,270 --> 00:12:22,950
Как писать алгоритмы,
которые могут обрабатывать

234
00:12:22,950 --> 00:12:26,270
так называемые числа
бесконечной точности?

235
00:12:26,270 --> 00:12:30,500
Поэтому у нас будет модуль о
числах в середине семестра,

236
00:12:30,500 --> 00:12:31,850
в котором мы поговорим
об этих вещах.

237
00:12:31,850 --> 00:12:35,480
Графы - это еще
одна фундаментальная

238
00:12:35,480 --> 00:12:37,970
структура данных 
в информатике.

239
00:12:37,970 --> 00:12:42,610
Вы наверняка слышали про 
известную задачку о кубике Рубика

240
00:12:42,610 --> 00:12:43,110
в курсе 6.006.

241
00:12:43,110 --> 00:12:46,850
Дан кубик Рубика размерами 2x2x2.

242
00:12:46,850 --> 00:12:48,690
Какое минимальное
количество шагов

243
00:12:48,690 --> 00:12:53,240
необходимо сделать, чтобы из
данной начальной конфигурации

244
00:12:53,240 --> 00:12:56,640
прийти к конечной конфигурации,
в которой каждая грань

245
00:12:56,640 --> 00:12:58,940
кубика окрашена
только в один цвет?

246
00:12:58,940 --> 00:13:01,830
Эту задачу можно
представить в виде графа.

247
00:13:01,830 --> 00:13:04,052
Возможно, мы сделаем
это в этом семестре.

248
00:13:04,052 --> 00:13:05,760
В предыдущих семестрах
мы делали другие интересные штуки,

249
00:13:05,760 --> 00:13:07,310
такие, как решение
головоломки "Пятнашки".

250
00:13:07,310 --> 00:13:10,170
На самом деле эти варианты
не окончательные.

251
00:13:10,170 --> 00:13:12,420
Мы точно знаем, что будет
в первой домашней работе,

252
00:13:12,420 --> 00:13:16,420
остальные задания на
данный момент предварительные.

253
00:13:16,420 --> 00:13:20,340
Закончится модуль о графах
задачей поиска кратчайшего пути.

254
00:13:20,340 --> 00:13:24,660
В прошлых семестрах
мы просили студентов

255
00:13:24,660 --> 00:13:27,380
написать код, который,
используя определенный

256
00:13:27,380 --> 00:13:30,984
алгоритм, находил бы кратчайший
путь из КалТеха в МИТ.

257
00:13:30,984 --> 00:13:33,150
В этот раз мы хотим
немного изменить подход.

258
00:13:33,150 --> 00:13:37,150
Мы подумали, что, быть может, дадим
вам городскую карту Бостона

259
00:13:37,150 --> 00:13:41,360
и вы выясните,
использовал ли Пол Реви́р

260
00:13:41,360 --> 00:13:44,140
кратчайшие пути, когда
ходил по своим делам.

261
00:13:44,140 --> 00:13:45,025
что-то такое вас ждет.

262
00:13:45,025 --> 00:13:47,540
Мы постараемся придумать
интересное задание.

263
00:13:47,540 --> 00:13:54,420
Динамическое программирование.
Эта важная техника разработки

264
00:13:54,420 --> 00:14:00,690
алгоритмов, которая используется
в очень многих задачах.

265
00:14:00,690 --> 00:14:04,510
С помощью динамического
программирования можно делать

266
00:14:04,510 --> 00:14:06,600
много интересных вещей,
включая сжатие изображений.

267
00:14:06,600 --> 00:14:10,060
Как сжать изображение, чтобы
количество пикселей в нем уменьшилось,

268
00:14:10,060 --> 00:14:12,960
при этом само изображение
выглядело бы как то,

269
00:14:12,960 --> 00:14:15,761
что имеет изначальное, намного
большее, количество пикселей?

270
00:14:15,761 --> 00:14:16,260
Ясно, да?

271
00:14:16,260 --> 00:14:18,970
Так вот, вы можете использовать для
этого динамическоое программирование.

272
00:14:18,970 --> 00:14:23,370
И наконец, продвинутые темы:
теория сложности алгоритмов

273
00:14:23,370 --> 00:14:25,760
и исследование алгоритмов.

274
00:14:25,760 --> 00:14:28,590
Надеюсь, к этому моменту
вы убедились в том,

275
00:14:28,590 --> 00:14:30,330
что алгоритмы это
интересно.

276
00:14:30,330 --> 00:14:32,605
И большинство из вас,
а, может быть, и все,

277
00:14:32,605 --> 00:14:34,550
хотело бы продолжить
карьеру в этой области.

278
00:14:34,550 --> 00:14:37,680
Также мы расскажем вам, что
еще есть в алгоритмах.

279
00:14:37,680 --> 00:14:40,364
То есть в этом курсе мы
лишь приоткроем дверь.

280
00:14:40,364 --> 00:14:42,530
А дальше есть много-много
курсов, которые вы можете пройти,

281
00:14:42,530 --> 00:14:47,650
если хотите продолжить
изучать алгоритмы

282
00:14:47,650 --> 00:14:49,790
или делать карьеру
в этой области.

283
00:14:49,790 --> 00:14:51,580
Что ж.

284
00:14:51,580 --> 00:14:53,990
Это был обзор того,
что ваш ждет

285
00:14:53,990 --> 00:14:55,840
в этом курсе.

286
00:14:55,840 --> 00:15:01,950
Будет здорово, если вы потратите
немного времени и зайдете на сайт курса.

287
00:15:01,950 --> 00:15:05,850
Я бы хотел, чтобы вы прочитали
о правилах прохождения курса

288
00:15:05,850 --> 00:15:08,440
и поняли, чего
мы от вас ждем.

289
00:15:08,440 --> 00:15:13,580
Просмотрите правила сдачи
домашних заданий,

290
00:15:13,580 --> 00:15:17,100
узнайте, сколько баллов
дается за домашние задания,

291
00:15:17,100 --> 00:15:20,860
как выставляется итоговая
оценка, все это есть на сайте.

292
00:15:20,860 --> 00:15:23,000
Вот так.

293
00:15:23,000 --> 00:15:23,870
Хорошо.

294
00:15:23,870 --> 00:15:26,210
Давайте начнем.

295
00:15:26,210 --> 00:15:28,930
Я хочу поговорить о
конкретной задаче.

296
00:15:28,930 --> 00:15:32,000
И о алгоритмах для
решения этой задачи.

297
00:15:32,000 --> 00:15:35,560
Мы выбрали именно эту задачу,
так как она очень легка

298
00:15:35,560 --> 00:15:38,790
для понимания и есть
очень простые алгоритмы

299
00:15:38,790 --> 00:15:41,280
для её решения, но
не обладающие

300
00:15:41,280 --> 00:15:42,530
достаточной эффективностью.

301
00:15:42,530 --> 00:15:45,060
Если так можно выразиться,
это детская задачка.

302
00:15:45,060 --> 00:15:49,660
Но как и многие другие
детские задачки,

303
00:15:49,660 --> 00:15:55,230
эта поможет вам
быстрее понять то, каким

304
00:15:55,230 --> 00:15:57,739
образом можно разрабатывать
эффективные алгоритмы.

305
00:15:57,739 --> 00:15:59,280
Итак, сначала мы рассмотрим
одномерный случай задачи,

306
00:15:59,280 --> 00:16:02,395
которая называется
поиск локального максимума.

307
00:16:02,395 --> 00:16:05,810


308
00:16:05,810 --> 00:16:10,635
Мы рассмотрим алгоритм.

309
00:16:10,635 --> 00:16:14,180


310
00:16:14,180 --> 00:16:18,240
Который работает
с массивом чисел.

311
00:16:18,240 --> 00:16:22,770
Я обозначу

312
00:16:22,770 --> 00:16:27,020
каждый число в массиве
латинской буквой.

313
00:16:27,020 --> 00:16:31,546
Эти числа могут быть
положительными

314
00:16:31,546 --> 00:16:33,170
или отрицательными. Но мы
будем считать, что

315
00:16:33,170 --> 00:16:34,480
все числа положительные,
сейчас это совершенно не важно.

316
00:16:34,480 --> 00:16:38,460
Алгоритмы, о которых я расскажу
будут работать в любом случае.

317
00:16:38,460 --> 00:16:41,330
Итак, у нас есть
одномерный массив,

318
00:16:41,330 --> 00:16:43,450
в котором девять
различных позиций.

319
00:16:43,450 --> 00:16:47,405
И есть числа, помеченные
буквами от a до i.

320
00:16:47,405 --> 00:16:49,910


321
00:16:49,910 --> 00:16:53,030
И мы хотим найти
локальный максимум.

322
00:16:53,030 --> 00:16:56,180
Для начала, давайте
поймем, что это такое.

323
00:16:56,180 --> 00:17:00,320
В частности,
например, элемент

324
00:17:00,320 --> 00:17:07,369
на позиции 2 будет
локальным максимумом

325
00:17:07,369 --> 00:17:16,520
тогда и только тогда, если
число b больше либо равно a,

326
00:17:16,520 --> 00:17:18,020
и в то же время число b
больше либо равно числа c.

327
00:17:18,020 --> 00:17:21,359
Как видно, свойства
этого понятия

328
00:17:21,359 --> 00:17:22,270
очень локальны.

329
00:17:22,270 --> 00:17:25,020
Для одномерного случая
определение очевидно.

330
00:17:25,020 --> 00:17:26,220
Посмотрите на число слева.

331
00:17:26,220 --> 00:17:27,990
Посмотрите на число справа.

332
00:17:27,990 --> 00:17:31,990
Если ваше число больше
либо равно тех, что

333
00:17:31,990 --> 00:17:35,120
находятся слева и справа,
вы в локальном максимуме.

334
00:17:35,120 --> 00:17:35,760
Просто, да?

335
00:17:35,760 --> 00:17:38,690
В граничных случаях

336
00:17:38,690 --> 00:17:40,700
вам достаточно посмотреть
только в одну сторону.

337
00:17:40,700 --> 00:17:53,567
Элемент на позиции 9 -
локальный максимум, если

338
00:17:53,567 --> 00:17:55,400
число i больше либо равно h.
Вам достаточно оценить число

339
00:17:55,400 --> 00:17:57,483
слева, посколько правее
вас элементов нет.

340
00:17:57,483 --> 00:17:58,270
С этим понятно?

341
00:17:58,270 --> 00:18:00,480
Это и есть определение
локального максимума.

342
00:18:00,480 --> 00:18:03,920
И условие задачи для
одномерного случая такое:

343
00:18:03,920 --> 00:18:13,820
найти локальный максимум,
если он существует.

344
00:18:13,820 --> 00:18:19,490


345
00:18:19,490 --> 00:18:22,070
Понятно, да?

346
00:18:22,070 --> 00:18:24,510
На этом все, что
касается определений.

347
00:18:24,510 --> 00:18:27,890
Сейчас я расскажу о решении
с помощью наивного алгоритма.

348
00:18:27,890 --> 00:18:30,630
А затем мы посмотрим, можно
ли как-то улучшить его.

349
00:18:30,630 --> 00:18:31,270
Хорошо?

350
00:18:31,270 --> 00:18:34,110
Можете думать об этом
простом алгоритме, как о чем-то,

351
00:18:34,110 --> 00:18:39,440
что просто проходит
весь массив.

352
00:18:39,440 --> 00:18:43,629
Но это хорошая отправная
точка для того, чтобы

353
00:18:43,629 --> 00:18:44,420
придумать что-то
более сложное.

354
00:18:44,420 --> 00:18:49,680


355
00:18:49,680 --> 00:18:57,340
То есть мы начинаем
с самого левого элемента

356
00:18:57,340 --> 00:19:01,500
и просто просматриваем
весь массив один раз.

357
00:19:01,500 --> 00:19:05,360


358
00:19:05,360 --> 00:19:07,930
Пусть есть элементы с индексами
1, 2, и вот здесь элемент

359
00:19:07,930 --> 00:19:10,810
с индексом n/2, который
соответствует элементу

360
00:19:10,810 --> 00:19:14,620
в середине массива
из n элементов.

361
00:19:14,620 --> 00:19:18,970
И в конце у нас элементы
с индексами n-1 и n.

362
00:19:18,970 --> 00:19:21,090
Здесь мне важно
не только описать

363
00:19:21,090 --> 00:19:24,880
как работает
наивный алгоритм,

364
00:19:24,880 --> 00:19:29,300
но и дать точную
оценку его сложности

365
00:19:29,300 --> 00:19:32,030
относительно n,
то есть по отношению

366
00:19:32,030 --> 00:19:35,260
к размеру
входных данных.

367
00:19:35,260 --> 00:19:35,760
Да?

368
00:19:35,760 --> 00:19:36,915
У вас есть вопрос?

369
00:19:36,915 --> 00:19:38,456
ГОЛОС ИЗ АУДИТОРИИ: Почему
вы говорите "если элемент существует",

370
00:19:38,456 --> 00:19:40,348
ведь условие "больше либо равно"
в определении локального

371
00:19:40,348 --> 00:19:41,397
максимума гарантирует то,
что он будет существовать?

372
00:19:41,397 --> 00:19:42,730
ПРОФЕССОР: Вы правы, это так.

373
00:19:42,730 --> 00:19:44,540
Я собирался уточнить это.

374
00:19:44,540 --> 00:19:50,530
Если посмотреть на
определение локального

375
00:19:50,530 --> 00:19:55,210
максимума, мы увидим слова
"больше либо равен чего-то".

376
00:19:55,210 --> 00:19:56,010
Видите?

377
00:19:56,010 --> 00:19:59,660
Поэтому был задан очень
хороший вопрос.

378
00:19:59,660 --> 00:20:04,470
Почему в определении я говорю
"если элемент существует"?

379
00:20:04,470 --> 00:20:08,440
Ведь в случае, когда мы
говорим "больше либо равен",

380
00:20:08,440 --> 00:20:12,310
любой массив будет иметь
локальный максимум.

381
00:20:12,310 --> 00:20:18,240
И вашим домашним
заданием будет

382
00:20:18,240 --> 00:20:19,610
доказать это утверждение.

383
00:20:19,610 --> 00:20:20,790
Хорошо?

384
00:20:20,790 --> 00:20:24,300
А если бы у нас было не
"больше либо равно",

385
00:20:24,300 --> 00:20:29,070
а просто "больше", как вы
думаете, смогли бы вы доказать это?

386
00:20:29,070 --> 00:20:30,120
На самом деле нет.

387
00:20:30,120 --> 00:20:30,820
Понимаете?

388
00:20:30,820 --> 00:20:33,230
Очень хороший вопрос.

389
00:20:33,230 --> 00:20:35,859
В данном случае это
просто вопрос -

390
00:20:35,859 --> 00:20:37,400
Если бы у меня было другое
другое определение

391
00:20:37,400 --> 00:20:38,950
локального максимума,
вы бы просто поменяли

392
00:20:38,950 --> 00:20:43,710
условие, чтобы найти
этот локальный максимум.

393
00:20:43,710 --> 00:20:45,850
И это часть того, что называют
алгоритмическим мышлением.

394
00:20:45,850 --> 00:20:49,580
Вы должны уметь создавать
алгоритмы для общих случаев,

395
00:20:49,580 --> 00:20:52,130
то есть, если определение
вдруг изменится

396
00:20:52,130 --> 00:20:54,300
у вас по-прежнему есть
отправная точка для того,

397
00:20:54,300 --> 00:20:56,500
чтобы решить другую
версию задачи.

398
00:20:56,500 --> 00:20:57,310
С этим понятно?

399
00:20:57,310 --> 00:21:01,479
Поэтому вы можете
убрать эти слова

400
00:21:01,479 --> 00:21:03,270
в случае, когда условие
содержит "больше либо равно".

401
00:21:03,270 --> 00:21:05,664
Можете убрать слова "если он существует",
потому что он всегда существует.

402
00:21:05,664 --> 00:21:07,330
Но, скорее всего, вы
захотите доказать это

403
00:21:07,330 --> 00:21:09,950
утверждение, чтобы показать,
что ваш алгоритм корректен.

404
00:21:09,950 --> 00:21:13,210
И если бы у вас было другое
определение, что ж, тогда вам

405
00:21:13,210 --> 00:21:19,130
пришлось бы разработать
алгоритм, который говорит,

406
00:21:19,130 --> 00:21:22,310
что локального максимума
в массиве нет, или же находит

407
00:21:22,310 --> 00:21:23,900
этот локальный максимум,
если он существует.

408
00:21:23,900 --> 00:21:24,400
Понятно?

409
00:21:24,400 --> 00:21:26,300
Это и есть
общий случай.

410
00:21:26,300 --> 00:21:29,830
Может так случиться, что
мы попросим вас что-либо сделать,

411
00:21:29,830 --> 00:21:34,990
но вы не сможете найти ответ,
который помог бы вам это сделать.

412
00:21:34,990 --> 00:21:39,335
Или не сможете найти ответ, который
удовлетворял бы всем ограничениям.

413
00:21:39,335 --> 00:21:41,710
В этом случае вы
должны поднять руку

414
00:21:41,710 --> 00:21:43,470
и сказать: "Знаете,

415
00:21:43,470 --> 00:21:44,870
Я долго и упорно
разбирался в проблеме.

416
00:21:44,870 --> 00:21:46,730
Я перепробовал
все варианты.

417
00:21:46,730 --> 00:21:49,930
Вот доказательства того, что 
я действительно пытался.

418
00:21:49,930 --> 00:21:51,101
Но у меня все равно
не получается."

419
00:21:51,101 --> 00:21:51,600
Ясно?

420
00:21:51,600 --> 00:21:53,490
Если вы cделаете это,
вы сможете продвинуться.

421
00:21:53,490 --> 00:21:54,580
Хорошо?

422
00:21:54,580 --> 00:21:57,390
С другой стороны всегда
есть вероятность того,

423
00:21:57,390 --> 00:21:59,060
что вы не попытались
решить задачу своими силами.

424
00:21:59,060 --> 00:22:02,310
Поэтому хорошо, если вы
покажете, что это не так.

425
00:22:02,310 --> 00:22:02,810
С этим понятно?

426
00:22:02,810 --> 00:22:03,080
Замечательно.

427
00:22:03,080 --> 00:22:04,190
Спасибо за вопрос.

428
00:22:04,190 --> 00:22:05,170
Не стесняйтесь
перебивать меня.

429
00:22:05,170 --> 00:22:07,840
Я постоянно слежу за вами,
поэтому поднимите руку,

430
00:22:07,840 --> 00:22:11,550
и я в любой момент с
радостью отвечу на вопросы.

431
00:22:11,550 --> 00:22:14,540
Что ж, давайте перейдем
к наивному алгоритму.

432
00:22:14,540 --> 00:22:16,510
Этот алгоритм начинает
свою работу с самого

433
00:22:16,510 --> 00:22:20,940
левого элемента и просто
идет по всему массиву.

434
00:22:20,940 --> 00:22:24,285
И у вас может быть что-то
наподобие этого.

435
00:22:24,285 --> 00:22:24,960
Вот так.

436
00:22:24,960 --> 00:22:27,830
Это означает, что
числа возрастают

437
00:22:27,830 --> 00:22:30,730
с левого конца, локальный
максимум где-то

438
00:22:30,730 --> 00:22:33,620
в середине, и далее
числа начинают убывать.

439
00:22:33,620 --> 00:22:34,120
Понятно, да?

440
00:22:34,120 --> 00:22:39,570
В этом случае вот здесь может
быть локальный максимум.

441
00:22:39,570 --> 00:22:46,950


442
00:22:46,950 --> 00:22:49,550
Также может возникнуть
ситуация, когда

443
00:22:49,550 --> 00:22:51,240
вы идете слева и
локальный максимум

444
00:22:51,240 --> 00:22:52,780
постоянно находится справа.

445
00:22:52,780 --> 00:22:55,060
Пример такого массива - 
это числа 1, 2, 3, 4, 5, 6

446
00:22:55,060 --> 00:22:56,390
и так далее.

447
00:22:56,390 --> 00:23:01,000
И в этом случае вы должны
просмотреть все n элементов

448
00:23:01,000 --> 00:23:04,800
идя слева направо, чтобы
найти локальный максимум.

449
00:23:04,800 --> 00:23:07,310
В случае, когда локальный
максимум в середине, вы

450
00:23:07,310 --> 00:23:10,940
должны просмотреть
n/2 элементов.

451
00:23:10,940 --> 00:23:13,770


452
00:23:13,770 --> 00:23:15,020
При условии, что локальный
максимум точно в середине.

453
00:23:15,020 --> 00:23:18,340


454
00:23:18,340 --> 00:23:26,340
И сложность в худшем
случае будет равна

455
00:23:26,340 --> 00:23:29,830
так называемому θ(n).
Читается как "Тета от n".

456
00:23:29,830 --> 00:23:33,580
Оно равно θ(n),
потому что в худшем случае

457
00:23:33,580 --> 00:23:36,294
вам необходимо просмотреть
все n элементов.

458
00:23:36,294 --> 00:23:38,710
Это как раз тот случай, когда
вы начали с левого конца

459
00:23:38,710 --> 00:23:40,860
и просмотрели все элементы,
до крайнего правого.

460
00:23:40,860 --> 00:23:43,850
θ(n), в сущности,
говорит нам

461
00:23:43,850 --> 00:23:45,830
о порядке n.

462
00:23:45,830 --> 00:23:49,400
То есть оно дает нам нижнюю
и верхнюю оценки.

463
00:23:49,400 --> 00:23:52,470
O(n) - "О-большое от эн" -
дает только верхнюю границу.

464
00:23:52,470 --> 00:23:53,970
Этим я хочу сказать,
что наш алгоритм,

465
00:23:53,970 --> 00:23:58,110
который просматривает
массив слева направо,

466
00:23:58,110 --> 00:24:03,470
в худшем случае
работает за время

467
00:24:03,470 --> 00:24:06,740
равное некоторой константе,
умноженной на n.

468
00:24:06,740 --> 00:24:07,880
Ясно?

469
00:24:07,880 --> 00:24:11,210
Эта константа может
быть равной 1.

470
00:24:11,210 --> 00:24:13,400
Пока нам достаточно
такой точности.

471
00:24:13,400 --> 00:24:15,860
Если бы у нас был другой
алгоритм, мы могли бы

472
00:24:15,860 --> 00:24:18,460
прикинуть, чему
равна константа.

473
00:24:18,460 --> 00:24:22,360
Но в конечном итоге, на
данный момент, нас волнует

474
00:24:22,360 --> 00:24:24,760
только асимптотическая сложность.

475
00:24:24,760 --> 00:24:29,030
И асимптотическая сложность
этого алгоритма линейна.

476
00:24:29,030 --> 00:24:29,710
Хорошо?

477
00:24:29,710 --> 00:24:32,150
Это понятно?

478
00:24:32,150 --> 00:24:32,930
Хорошо.

479
00:24:32,930 --> 00:24:38,950
Теперь помогите мне
улучшить этот алгоритм.

480
00:24:38,950 --> 00:24:39,890
Как мы можем это сделать?

481
00:24:39,890 --> 00:24:43,040
Как мы можем понизить
асимптотическую сложность

482
00:24:43,040 --> 00:24:46,700
алгоритма поиска локального
максимума в массиве?

483
00:24:46,700 --> 00:24:48,450
Кто-нибудь
хочет рискнуть?

484
00:24:48,450 --> 00:24:48,950
Ну что?

485
00:24:48,950 --> 00:24:50,086
Да, вот там.

486
00:24:50,086 --> 00:24:52,078
ГОЛОС ИЗ АУДИТОРИИ: Можно
использовать бинарный поиск.

487
00:24:52,078 --> 00:24:54,236
Мы смотрим на
элемент в середине

488
00:24:54,236 --> 00:24:58,552
и отбрасываем половину
массива, в зависимости от

489
00:24:58,552 --> 00:25:00,290
того, где находится
локальный максимум.

490
00:25:00,290 --> 00:25:00,410
ПРОФЕССОР: Так.

491
00:25:00,410 --> 00:25:01,578
ГОЛОС ИЗ АУДИТОРИИ: Например,
если мы в находимся в середине,

492
00:25:01,578 --> 00:25:03,492
мы знаем, что все элементы
справа больше, чем тот, на

493
00:25:03,492 --> 00:25:05,116
который мы смотрим.
Поэтому мы можем сказать,

494
00:25:05,116 --> 00:25:06,946
что локальный максимум
где-то там,

495
00:25:06,946 --> 00:25:07,446
в правой половине

496
00:25:07,446 --> 00:25:08,900
Таким же образом мы продолжаем
делить массив пополам.

497
00:25:08,900 --> 00:25:09,360
ПРОФЕССОР: Превосходно!

498
00:25:09,360 --> 00:25:09,859
Просто превосходно!

499
00:25:09,859 --> 00:25:11,200
Именно так.

500
00:25:11,200 --> 00:25:14,850
Вы можете использовать
что-то другое.

501
00:25:14,850 --> 00:25:19,240
Например, разбить эту
задачу на более мелкие.

502
00:25:19,240 --> 00:25:22,650
Используя стратегию "разделяй и
властвуй", рекурсивно разбиваем

503
00:25:22,650 --> 00:25:26,550
этот одномерный массив на
более мелкие массивы.

504
00:25:26,550 --> 00:25:29,940
Этим мы пытаемся
снизить сложность.

505
00:25:29,940 --> 00:25:30,440
Да?

506
00:25:30,440 --> 00:25:33,239
ГОЛОС ИЗ АУДИТОРИИ: Подразумевается,
что в массиве только один локальный

507
00:25:33,239 --> 00:25:34,280
максимум?
ПРОФЕССОР: Нет, не обязательно.

508
00:25:34,280 --> 00:25:34,980
ГОЛОС ИЗ АУДИТОРИИ: Ясно.

509
00:25:34,980 --> 00:25:39,219
ПРОФЕССОР: Алгоритм
найдет локальный максимум,

510
00:25:39,219 --> 00:25:40,760
если он существует.

511
00:25:40,760 --> 00:25:42,610
Этот так просто
по определению.

512
00:25:42,610 --> 00:25:45,910
На самом деле мы уже
обсудили, что это нам не нужно.

513
00:25:45,910 --> 00:25:46,660
С этим ясно?

514
00:25:46,660 --> 00:25:47,180
Хорошо.

515
00:25:47,180 --> 00:25:49,080
Итак,

516
00:25:49,080 --> 00:25:53,392
это был отличный ответ.
Знаете, спустя некоторое

517
00:25:53,392 --> 00:25:54,850
время лекция
становится скучновата.

518
00:25:54,850 --> 00:25:55,770
Не так ли?

519
00:25:55,770 --> 00:25:57,650
Каждая лекция в какой-то
момент становится скучной.

520
00:25:57,650 --> 00:26:00,777
Поэтому мы попробуем немного
разбавить монотонную речь.

521
00:26:00,777 --> 00:26:02,860
Кроме этого, мы поняли
еще одну вещь.

522
00:26:02,860 --> 00:26:04,790
Ваши стулья, - те,
на которых вы сидите

523
00:26:04,790 --> 00:26:06,998
в этой прекрасной
аудитории, - эти стулья

524
00:26:06,998 --> 00:26:07,750
не очень-то удобны.

525
00:26:07,750 --> 00:26:08,250
Верно?

526
00:26:08,250 --> 00:26:10,787
И вот что мы вместе с
Эриком решили:

527
00:26:10,787 --> 00:26:12,620
мы будем помогать вам.
Особенно тем из вас,

528
00:26:12,620 --> 00:26:15,870
кто будет активно
участвовать в лекции.

529
00:26:15,870 --> 00:26:17,580
И у нас вот здесь есть

530
00:26:17,580 --> 00:26:18,610
[СМЕХ В АУДИТОРИИ]

531
00:26:18,610 --> 00:26:22,145
подушки. Специальные
подушки для нашего курса.

532
00:26:22,145 --> 00:26:25,170
А еще здесь есть кубик
Рубика размером 2x2x2.

533
00:26:25,170 --> 00:26:28,410
И так как вы ответили на первый
вопрос, вы получаете подушку.

534
00:26:28,410 --> 00:26:31,510
Она похоже на Фрисби,
но это не Фрисби.

535
00:26:31,510 --> 00:26:32,010
Итак.

536
00:26:32,010 --> 00:26:32,510
[СМЕХ В АУДИТОРИИ]

537
00:26:32,510 --> 00:26:35,190
Э... Где же вы? Вот, вы.
Я собираюсь дать ее вам.

538
00:26:35,190 --> 00:26:36,565
Но я хочу сказать еще
кое-что. Я хочу сказать,

539
00:26:36,565 --> 00:26:37,970
что это не бейсбол.

540
00:26:37,970 --> 00:26:38,469
Понимаете?

541
00:26:38,469 --> 00:26:40,560
Не надо хватать подушку,
как только она долетит до вас.

542
00:26:40,560 --> 00:26:43,670
Конкретно эта для него, парня
в красной футболке.

543
00:26:43,670 --> 00:26:45,920
Ловите.

544
00:26:45,920 --> 00:26:46,820
Оу, нехорошо.

545
00:26:46,820 --> 00:26:47,620
Вот так.

546
00:26:47,620 --> 00:26:48,580
Она мягкая.

547
00:26:48,580 --> 00:26:51,255
Вы не пострадаете,
если она попадет в вас.

548
00:26:51,255 --> 00:26:51,910
[СМЕХ В АУДИТОРИИ]

549
00:26:51,910 --> 00:26:52,540
Хорошо.

550
00:26:52,540 --> 00:26:54,216
Имейте в виду, что
у нас есть много подушек.

551
00:26:54,216 --> 00:26:57,300
Так что поднимайте руки.

552
00:26:57,300 --> 00:27:01,025
Также некоторые из тех вопросов,
что мы будем задавать,

553
00:27:01,025 --> 00:27:03,150
будут очень-очень простыми.
Просто для того, чтобы убедиться

554
00:27:03,150 --> 00:27:05,180
в том, что вы не заснули.

555
00:27:05,180 --> 00:27:07,750
Ответ на такой вопрос
не принесет вам подушку.

556
00:27:07,750 --> 00:27:10,514
А вот такой ответ, как у...
Скажите, как вас зовут?

557
00:27:10,514 --> 00:27:11,180
ГОЛОС ИЗ АУДИТОРИИ: Чейз.

558
00:27:11,180 --> 00:27:11,890
ПРОФЕССОР: Чейз.

559
00:27:11,890 --> 00:27:15,134
Такой ответ,
как у Чейза,

560
00:27:15,134 --> 00:27:17,050
это хороший ответ на
непростой вопрос.

561
00:27:17,050 --> 00:27:18,500
После такого ответа
вы заслуживаете подушку.

562
00:27:18,500 --> 00:27:19,290
Ясно?

563
00:27:19,290 --> 00:27:20,300
Хорошо, идем дальше.

564
00:27:20,300 --> 00:27:24,230
Давайте применим
алгоритм Чейза.

565
00:27:24,230 --> 00:27:26,510
Я напишу его для
одномерной версии задачи.

566
00:27:26,510 --> 00:27:41,390


567
00:27:41,390 --> 00:27:45,205
Итак, это будет
рекурсивный алгоритм.

568
00:27:45,205 --> 00:28:02,967


569
00:28:02,967 --> 00:28:04,800
Для понимания работы
алгоритма мы будем

570
00:28:04,800 --> 00:28:06,860
использовать вот
этот рисунок.

571
00:28:06,860 --> 00:28:11,010
Алгоритм основан на методе
"разделяй и властвуй".

572
00:28:11,010 --> 00:28:14,140
Вы встретите этот подход
еще много раз в нашем

573
00:28:14,140 --> 00:28:17,360
курсе.

574
00:28:17,360 --> 00:28:22,745
Мы смотрим элемент
на позиции n/2.

575
00:28:22,745 --> 00:28:25,990


576
00:28:25,990 --> 00:28:28,700
Затем смотрим
налево.

577
00:28:28,700 --> 00:28:31,010
А затем направо.

578
00:28:31,010 --> 00:28:33,420
И делаем это
последовательно.

579
00:28:33,420 --> 00:28:33,920
Итак,

580
00:28:33,920 --> 00:28:36,680


581
00:28:36,680 --> 00:28:50,950
если элемент с индексом n/2
меньше элемента с индексом n/2 - 1,

582
00:28:50,950 --> 00:28:54,380
тогда мы ищем локальный
максимум только в левой

583
00:28:54,380 --> 00:28:57,680


584
00:28:57,680 --> 00:29:04,410
половине. Просматриваем
индексы от 1 до n/2 - 1.

585
00:29:04,410 --> 00:29:08,381


586
00:29:08,381 --> 00:29:08,880
Понятно, да?.

587
00:29:08,880 --> 00:29:10,295
Это первый шаг
алгоритма.

588
00:29:10,295 --> 00:29:12,170
Я мог бы выбрать правую
половину массива или левую.

589
00:29:12,170 --> 00:29:15,990
Это сейчас не имеет
большого значения.

590
00:29:15,990 --> 00:29:20,311
Пускай это будет
левая половина.

591
00:29:20,311 --> 00:29:24,570
На самом деле, после того
как мы выполняем такой шаг,

592
00:29:24,570 --> 00:29:30,010
происходит вот что.
Если элемент с индексом n/2

593
00:29:30,010 --> 00:29:33,630
меньше, чем элемент с индексом n/2 - 1,
то мы переходим в левую половину

594
00:29:33,630 --> 00:29:37,490
массива и работаем с ней. Наша
задача уменьшается в два раза.

595
00:29:37,490 --> 00:29:43,120
Если же элемент с
индексом n/2 меньше

596
00:29:43,120 --> 00:29:48,170
элемента с индексом n/2 + 1,
мы переходим в правую половину

597
00:29:48,170 --> 00:29:57,520
и продолжаем поиск среди
индексов от n/2 + 1 до n.

598
00:29:57,520 --> 00:29:59,960
Я не буду писать все
это на доске.

599
00:29:59,960 --> 00:30:03,480
Это все аналогично
левой части.

600
00:30:03,480 --> 00:30:06,160
Только здесь вы
смотрите направо.

601
00:30:06,160 --> 00:30:10,430
Если ни одно из этих
условий не выполнено,

602
00:30:10,430 --> 00:30:12,160
это означает, что вы
нашли локальный максимум.

603
00:30:12,160 --> 00:30:12,660
Ясно?

604
00:30:12,660 --> 00:30:16,130
Это наилучший случай с точки
зрения быстродействия,

605
00:30:16,130 --> 00:30:18,340
по крайней мере,
за один шаг рекурсии.

606
00:30:18,340 --> 00:30:22,580
Так как локальный максимум - 
это наш элемент с индексом n/2.

607
00:30:22,580 --> 00:30:27,210


608
00:30:27,210 --> 00:30:30,500
То есть мы видим, что
элемент с индексом n/2

609
00:30:30,500 --> 00:30:34,740
больше либо равен
соседних элементов,

610
00:30:34,740 --> 00:30:36,850
а это и есть определение
локального максимума.

611
00:30:36,850 --> 00:30:38,430
Все, мы нашли
локальный максимум.

612
00:30:38,430 --> 00:30:39,350
Ясно, да?

613
00:30:39,350 --> 00:30:44,500
Что ж, с этим разобрались.

614
00:30:44,500 --> 00:30:53,307
Вы можете захотеть доказать
корректность алгоритма.

615
00:30:53,307 --> 00:30:54,890
Я не собираюсь делать
это прямо сейчас.

616
00:30:54,890 --> 00:30:59,530
Я просто скажу
что это так,

617
00:30:59,530 --> 00:31:01,230
а вы поверите
мне на слово.

618
00:31:01,230 --> 00:31:07,310
Но учтите, что один из пунктов
вашего домашнего задания -

619
00:31:07,310 --> 00:31:11,560
доказательство корректности
более сложного алгоритма,

620
00:31:11,560 --> 00:31:12,720
для двумерной
версии задачи.

621
00:31:12,720 --> 00:31:16,900
И вот это будет хорошим
образцом для написания

622
00:31:16,900 --> 00:31:19,200
формального
доказательства того,

623
00:31:19,200 --> 00:31:21,620
что данный
алгоритм корректен.

624
00:31:21,620 --> 00:31:23,550
То есть алгоритм делает то,
что от него ожидается.

625
00:31:23,550 --> 00:31:30,370
Это буквально 2-3 строчки,
которые показывают,

626
00:31:30,370 --> 00:31:34,520
что, с данным определением
локального максимума,

627
00:31:34,520 --> 00:31:38,600
алгоритм найдет локальный
максимум в том массиве,

628
00:31:38,600 --> 00:31:39,860
который поступает
на вход.

629
00:31:39,860 --> 00:31:40,900
Все ясно?

630
00:31:40,900 --> 00:31:44,910
Итак, мы считаем, что
алгоритм корректен.

631
00:31:44,910 --> 00:31:48,650
Давайте теперь поговорим
о сложности этого алгоритма.

632
00:31:48,650 --> 00:31:50,630
Ведь это все
затевалось из-за того,

633
00:31:50,630 --> 00:31:52,700
что нас не устроила
асимптотическая сложность

634
00:31:52,700 --> 00:31:56,350
наивного алгоритма,
которая равнялась θ(n).

635
00:31:56,350 --> 00:31:57,470
Поэтому мы захотели
уменьшить ее.

636
00:31:57,470 --> 00:32:08,350


637
00:32:08,350 --> 00:32:10,830
Я бы хотел попросить
кого-нибудь из вас

638
00:32:10,830 --> 00:32:14,890
дать мне рекуррентное соотношение.
Вроде этого: Т(n) равняется тому-то,

639
00:32:14,890 --> 00:32:18,040
тому-то и тому-то.

640
00:32:18,040 --> 00:32:22,310
И чтобы оно описывало
этот рекурсивный алгоритм,

641
00:32:22,310 --> 00:32:24,020
алгоритм
"разделяй и властвуй".

642
00:32:24,020 --> 00:32:29,050
Тогда я, на основе этого,
смогу вычислить асимптотическую

643
00:32:29,050 --> 00:32:33,280
сложность алгоритма
в терминах Тета.

644
00:32:33,280 --> 00:32:33,780
Да?

645
00:32:33,780 --> 00:32:34,752
На задних рядах.

646
00:32:34,752 --> 00:32:39,680
ГОЛОС ИЗ АУДИТОРИИ: Ну,
в худшем случае, T(n)

647
00:32:39,680 --> 00:32:42,795
будет равняться некому
константному количеству времени,

648
00:32:42,795 --> 00:32:43,420
ПРОФЕССОР: Так.

649
00:32:43,420 --> 00:32:47,116
ГОЛОС ИЗ АУДИТОРИИ:
которое нужно, чтобы

650
00:32:47,116 --> 00:32:49,851
сравнить два элемента
и узнать, какой больше, плюс...

651
00:32:49,851 --> 00:32:50,713
[ЗВУК КАШЛЯ]

652
00:32:50,713 --> 00:32:52,022
плюс Т(n/2) ?

653
00:32:52,022 --> 00:32:52,730
ПРОФЕССОР: Отлично.

654
00:32:52,730 --> 00:32:53,550
Именно так.

655
00:32:53,550 --> 00:32:54,460
Все правильно.

656
00:32:54,460 --> 00:32:58,370
Итак, можно посмотреть на
этот алгоритм и спросите себя:

657
00:32:58,370 --> 00:33:01,290
можно ли написать
уравнение, которое

658
00:33:01,290 --> 00:33:05,510
соответствовало бы
выполнению алгоритма

659
00:33:05,510 --> 00:33:06,570
с точки зрения вычислений?

660
00:33:06,570 --> 00:33:11,350
Можно сказать, что T(n) -
это работа, которую алгоритм

661
00:33:11,350 --> 00:33:13,630
выполнит, если на вход
подать данные размера n.

662
00:33:13,630 --> 00:33:14,130
Так?

663
00:33:14,130 --> 00:33:25,390


664
00:33:25,390 --> 00:33:28,550
Тогда я могу написать
такое уравнение.

665
00:33:28,550 --> 00:33:31,310


666
00:33:31,310 --> 00:33:34,530
θ(1) соответствует
двум сравнениям,

667
00:33:34,530 --> 00:33:37,697
которые вы потенциально
делаете, когда смотрите

668
00:33:37,697 --> 00:33:39,280
на элемент слева

669
00:33:39,280 --> 00:33:41,440
и на элемент справа.

670
00:33:41,440 --> 00:33:44,580
Два сравнения. Два - это константа,
поэтому мы пишем здесь θ(1).

671
00:33:44,580 --> 00:33:45,200
Ясно?

672
00:33:45,200 --> 00:33:47,060
Что ж, вы заработали подушку.

673
00:33:47,060 --> 00:33:49,630
Аккуратнее.

674
00:33:49,630 --> 00:33:50,780
Оу!

675
00:33:50,780 --> 00:33:52,192
На самом деле,
я почти попал.

676
00:33:52,192 --> 00:33:54,000
Хорошо.

677
00:33:54,000 --> 00:33:55,620
Отклоняются влево, Эрик.

678
00:33:55,620 --> 00:33:57,420
Подушки отклоняются влево.

679
00:33:57,420 --> 00:34:03,360
Итак, если вы возьмете
правую часть и начнете

680
00:34:03,360 --> 00:34:05,180
разворачивать ее, в
конечном итоге вы дойдете

681
00:34:05,180 --> 00:34:12,091
до базового случая - 
Т(1) = θ(1).

682
00:34:12,091 --> 00:34:12,590
Так.

683
00:34:12,590 --> 00:34:16,580
То есть у вас есть массив
из одного элемента и вы

684
00:34:16,580 --> 00:34:19,650
просто возвращаете элемент
как локальный максимум.

685
00:34:19,650 --> 00:34:23,130
И после того, как вы развернете
рекурсию до базового случая,

686
00:34:23,130 --> 00:34:31,080
можно сказать, что
T(n) = θ(1) + ... + θ(1).

687
00:34:31,080 --> 00:34:39,300
В правой части у нас
log2(n) слагаемых.

688
00:34:39,300 --> 00:34:43,660
Поэтому, суммируя
их все, получаем, что

689
00:34:43,660 --> 00:34:46,360
сложность будет такой:
θ(log2(n))

690
00:34:46,360 --> 00:34:48,330
Ясно?

691
00:34:48,330 --> 00:34:53,089
Теперь сравниваем
этот результат с этим.

692
00:34:53,089 --> 00:34:54,630
И видим действительно
огромную разницу.

693
00:34:54,630 --> 00:34:57,440
Это, в действительности,
экспоненциальная разница.

694
00:34:57,440 --> 00:35:01,860
Если вы реализуете эти
алгоритмы на Python,

695
00:35:01,860 --> 00:35:06,170
я имею в виду алгоритмы для
одномерного случая,

696
00:35:06,170 --> 00:35:14,160
и запустите их на входных
данных порядка 10 миллионов

697
00:35:14,160 --> 00:35:17,820
элементов, то этот алгоритм
отработает за 13 секунд.

698
00:35:17,820 --> 00:35:18,320
Так?

699
00:35:18,320 --> 00:35:21,880
То есть алгоритм со сложностью
θ(n) отработает за 13 секунд.

700
00:35:21,880 --> 00:35:26,070
А время работы
вот этого 0.001 секунды.

701
00:35:26,070 --> 00:35:26,570
Видите?

702
00:35:26,570 --> 00:35:27,929
Огромная разница.

703
00:35:27,929 --> 00:35:30,345
Итак, мы увидели большую
разницу между сложностью

704
00:35:30,345 --> 00:35:31,970
θ(n) и θ(log(n)).

705
00:35:31,970 --> 00:35:35,840
Это как разница между
2 в степени n и n.

706
00:35:35,840 --> 00:35:40,120
Как вы видите, имеет смысл
попытаться и уменьшить

707
00:35:40,120 --> 00:35:43,000
сложность. Особенно,
если мы говорим о

708
00:35:43,000 --> 00:35:44,450
входных данных большого размера.

709
00:35:44,450 --> 00:35:45,390
Понятно, да?

710
00:35:45,390 --> 00:35:48,860
Это станет еще более
очевидным, когда

711
00:35:48,860 --> 00:35:51,300
мы перейдем к двумерному
случаю этой задачи.

712
00:35:51,300 --> 00:35:52,202
Хорошо.

713
00:35:52,202 --> 00:35:53,910
На самом деле мы не можем
решить эту задачу быстрее.

714
00:35:53,910 --> 00:35:56,750
Задача для одномерного
случая - это простая задача.

715
00:35:56,750 --> 00:35:58,500
Становится немного
интереснее,

716
00:35:58,500 --> 00:36:01,080
задача становится,
извините, то есть

717
00:36:01,080 --> 00:36:03,600
алгоритмы становятся
чуть более сложными,

718
00:36:03,600 --> 00:36:08,340
если посмотреть на эту
задачу для двумерной версии.

719
00:36:08,340 --> 00:36:10,535
Поэтому давайте рассмотрим
двумерный случай.

720
00:36:10,535 --> 00:36:15,810


721
00:36:15,810 --> 00:36:18,250
Как вы легко можете
представить, в этом

722
00:36:18,250 --> 00:36:20,715
случае у нас есть матрица
или двумерный массив.

723
00:36:20,715 --> 00:36:23,490


724
00:36:23,490 --> 00:36:29,575
Скажем, в ней n строк
и m столбцов.

725
00:36:29,575 --> 00:36:34,700


726
00:36:34,700 --> 00:36:37,190
Нам понадобится новое
определение локального максимума.

727
00:36:37,190 --> 00:36:38,350
Это своего рода возвышенность.

728
00:36:38,350 --> 00:36:41,540
Это очевидное определение
локального максимума.

729
00:36:41,540 --> 00:36:50,490
Это значит, если у вас
есть числа a, b, c, d, e,

730
00:36:50,490 --> 00:37:02,250
то a будет локальным максимумом
тогда, и только тогда,

731
00:37:02,250 --> 00:37:08,830
если a больше либо равно b,
a больше либо равно d,

732
00:37:08,830 --> 00:37:10,061
a больше либо равно c
и a больше либо равно e

733
00:37:10,061 --> 00:37:10,560
Понятно, да?

734
00:37:10,560 --> 00:37:12,230
То есть получается такая
маленькая возвышенность.

735
00:37:12,230 --> 00:37:12,730
Вот.

736
00:37:12,730 --> 00:37:15,120
И я опять говорю
"больше либо равно",

737
00:37:15,120 --> 00:37:18,490
то есть, как и в одномерном
случае, наша двумерная

738
00:37:18,490 --> 00:37:21,345
матрица всегда имеет
локальный максимум.

739
00:37:21,345 --> 00:37:23,960


740
00:37:23,960 --> 00:37:29,210
Теперь я снова дам
вам простой алгоритм,

741
00:37:29,210 --> 00:37:31,640
который называется
алгоритм жадного восхождения.

742
00:37:31,640 --> 00:37:41,660


743
00:37:41,660 --> 00:37:45,820
Этот алгоритм выбирает
какое-то направление

744
00:37:45,820 --> 00:37:50,560
и пытается идти
в этом направлении,

745
00:37:50,560 --> 00:37:52,770
чтобы найти
локальный максимум.

746
00:37:52,770 --> 00:38:01,840
Например, если у меня
есть вот такая матрица -

747
00:38:01,840 --> 00:38:10,790
с числами 14, 13,
12, 15, 9, 11, 17...

748
00:38:10,790 --> 00:38:17,010


749
00:38:17,010 --> 00:38:20,850
Тогда что произойдет,
если я начну с произвольной

750
00:38:20,850 --> 00:38:23,360
точки в середине - 
алгоритм жадного восхождения

751
00:38:23,360 --> 00:38:26,210
должен выбрать,
откуда начать.

752
00:38:26,210 --> 00:38:29,142
Как и в случае
одномерного массива

753
00:38:29,142 --> 00:38:31,100
вам нужно выбрать,
с чего начать.

754
00:38:31,100 --> 00:38:32,770
Вы можете начать
с середины

755
00:38:32,770 --> 00:38:35,560
и решить, что хотите
начать двигаться налево.

756
00:38:35,560 --> 00:38:38,380
И двигаться только налево

757
00:38:38,380 --> 00:38:39,720
или только направо.

758
00:38:39,720 --> 00:38:42,340
И если вы доходите
до края, то идете вниз.

759
00:38:42,340 --> 00:38:46,450
То есть вы выбираете,
какие направления нужно

760
00:38:46,450 --> 00:38:47,810
выбирать по-умолчанию.

761
00:38:47,810 --> 00:38:50,820
Если вы решили
начать с 12,

762
00:38:50,820 --> 00:38:54,050
вам нужно посмотреть
на число слева.

763
00:38:54,050 --> 00:38:58,470
Если число больше, вы
продолжаете идти в эту сторону.

764
00:38:58,470 --> 00:39:00,950
Если нет, то есть
если число меньше,

765
00:39:00,950 --> 00:39:04,200
тогда вы идете в другую
сторону, вот сюда,

766
00:39:04,200 --> 00:39:05,160
например.

767
00:39:05,160 --> 00:39:13,120
В нашем случае, вы проходите
12, 13, 14, 15, 16, 17, 19

768
00:39:13,120 --> 00:39:14,230
и 20.

769
00:39:14,230 --> 00:39:17,765
И вот здесь, здесь вы бы
нашли локальный максимум.

770
00:39:17,765 --> 00:39:21,680
Я сейчас не уточнил то,
как именно работает

771
00:39:21,680 --> 00:39:23,750
алгоритм жадного восхождения.

772
00:39:23,750 --> 00:39:33,400
Но, я думаю, что если вы
посмотрите на худшие

773
00:39:33,400 --> 00:39:36,370
возможные случаи
для этой матрицы

774
00:39:36,370 --> 00:39:38,920
и для любой из
начальных точек,

775
00:39:38,920 --> 00:39:43,270
и для любой стратегии
выбора того,

776
00:39:43,270 --> 00:39:48,630
куда нужно повернуть
в том или ином случае,

777
00:39:48,630 --> 00:39:51,370
у вас возникнет
ситуация,

778
00:39:51,370 --> 00:39:55,450
та же, что и в одномерном
случае, когда вы

779
00:39:55,450 --> 00:40:02,015
просмотрите значительную
часть элементов матрицы.

780
00:40:02,015 --> 00:40:02,750
Понимаете, да?

781
00:40:02,750 --> 00:40:05,190
В нашем примере
мы просмотрели

782
00:40:05,190 --> 00:40:06,890
множество
различных элементов.

783
00:40:06,890 --> 00:40:10,529
Вполне возможно,
что вы, начав

784
00:40:10,529 --> 00:40:12,820
с элемента в середине,
просмотрите половину

785
00:40:12,820 --> 00:40:16,990
элементов. А в некоторых
случаях вообще все элементы.

786
00:40:16,990 --> 00:40:23,000
То есть, если анализировать
худший случай этого алгоритма -

787
00:40:23,000 --> 00:40:25,410
конкретного алгоритма с
конкретной стратегией выбора

788
00:40:25,410 --> 00:40:30,370
начального элемента
и направлений поиска -

789
00:40:30,370 --> 00:40:33,750
мы получаем, что сложность
будет порядка θ(n * m).

790
00:40:33,750 --> 00:40:34,320
Все понятно?

791
00:40:34,320 --> 00:40:42,480
В случае, когда n равно
m, или m равно n,

792
00:40:42,480 --> 00:40:44,840
вы получите квадратичную
сложность θ(n^2).

793
00:40:44,840 --> 00:40:46,290
Ясно, да?

794
00:40:46,290 --> 00:40:48,440
Я не буду слишком подробно
останавливаться на этом,

795
00:40:48,440 --> 00:40:52,150
потому что хочу поговорить с вами
об алгоритмах поиска локального

796
00:40:52,150 --> 00:40:58,020
максимума, основанных на
парадигме "разделяй и властвуй".

797
00:40:58,020 --> 00:41:00,860
Но, надеюсь, что вы все согласны
со мной в том, что сложность

798
00:41:00,860 --> 00:41:03,530
в худшем случае
именно такая.

799
00:41:03,530 --> 00:41:04,990
Хорошо?

800
00:41:04,990 --> 00:41:06,070
Все согласны с этим?

801
00:41:06,070 --> 00:41:06,570
Да.

802
00:41:06,570 --> 00:41:07,390
Вопрос с заднего
ряда вот там.

803
00:41:07,390 --> 00:41:09,264
ГОЛОС ИЗ АУДИТОРИИ: Это
приближенное значение?

804
00:41:09,264 --> 00:41:14,630
Или мы должны сделать
в точности n*m шагов?

805
00:41:14,630 --> 00:41:18,780
ПРОФЕССОР: Есть такие варианты
алгоритма жадного восхождения

806
00:41:18,780 --> 00:41:21,680
и есть такие матрицы, что
если я дам вам код этого алгоритма

807
00:41:21,680 --> 00:41:24,680
и определенную,
конкретную матрицу,

808
00:41:24,680 --> 00:41:28,200
то вы обойдете все
элементы этой матрицы.

809
00:41:28,200 --> 00:41:28,870
В этом смысле
это так.

810
00:41:28,870 --> 00:41:30,600
Мы сейчас говорим
о худшем случае.

811
00:41:30,600 --> 00:41:32,260
Вы должны быть
параноиком, когда

812
00:41:32,260 --> 00:41:34,540
анализируете сложность
в худшем случае.

813
00:41:34,540 --> 00:41:38,800
И все, что я здесь делаю
выглядит, как какая-то магия,

814
00:41:38,800 --> 00:41:41,150
просто потому что я еще
не дал вам конкретного

815
00:41:41,150 --> 00:41:42,150
алгоритма.

816
00:41:42,150 --> 00:41:42,650
Хорошо?

817
00:41:42,650 --> 00:41:44,669
На самом деле, это
целый набор алгоритмов.

818
00:41:44,669 --> 00:41:46,210
Я не показал
вам код,

819
00:41:46,210 --> 00:41:47,668
я не сказал,
откуда мы начинаем,

820
00:41:47,668 --> 00:41:49,050
и в каком направлении идем.

821
00:41:49,050 --> 00:41:52,380
Но вы пойдёте, сделаете это,
улучшите, и я буду тем человеком,

822
00:41:52,380 --> 00:41:55,380
кто попытается оценить сложность
для худшего случая.

823
00:41:55,380 --> 00:41:58,250
Правда, очень легко получить
θ(n * m), то есть некоторую

824
00:41:58,250 --> 00:42:03,140
константу умноженную
на произведение n и m.

825
00:42:03,140 --> 00:42:05,810
Но вы точно можете
уменьшить эту константу,

826
00:42:05,810 --> 00:42:08,520
приблизить к единице.

827
00:42:08,520 --> 00:42:09,910
Понятно, да?

828
00:42:09,910 --> 00:42:11,350
А может даже и
сделать ее единицей.

829
00:42:11,350 --> 00:42:12,190
Хорошо.

830
00:42:12,190 --> 00:42:14,480
Что ж, давайте поговорим
о методе "разделяй и властвуй".

831
00:42:14,480 --> 00:42:18,720
Допустим, что я сделал
нечто похожее на

832
00:42:18,720 --> 00:42:22,770
алгоритм бинарного поиска,
только сделал это

833
00:42:22,770 --> 00:42:26,340
для двумерного случая.

834
00:42:26,340 --> 00:42:26,840
Здесь понятно?

835
00:42:26,840 --> 00:42:37,780


836
00:42:37,780 --> 00:42:43,830
То есть что я делаю:

837
00:42:43,830 --> 00:42:55,430
я выбираю столбец в середине,
с индексом j равным m/2.

838
00:42:55,430 --> 00:43:00,710
И я хочу найти локальный
максимум для одномерного

839
00:43:00,710 --> 00:43:01,810
случая с помощью какого-
нибудь алгоритма.

840
00:43:01,810 --> 00:43:04,820
И, скорее всего, я буду использовать
более эффективный алгоритм,

841
00:43:04,820 --> 00:43:07,850
вроде версии с бинарном
поиском, которой я исписал

842
00:43:07,850 --> 00:43:10,530
всю доску слева, вот там.

843
00:43:10,530 --> 00:43:14,000
И допустим я нашел локальный
макусимум в точке (i, j).

844
00:43:14,000 --> 00:43:17,060
Так как я выбрал конкретный столбец
и просто ищу локальный максимум в нем.

845
00:43:17,060 --> 00:43:20,320


846
00:43:20,320 --> 00:43:23,550
Так, j равняется m/2.

847
00:43:23,550 --> 00:43:25,690
Это строка имеет индекс i.

848
00:43:25,690 --> 00:43:29,850
И теперь я
через (i, j) обозначу

849
00:43:29,850 --> 00:43:38,730
элемент в конкретной
строке i, с которого

850
00:43:38,730 --> 00:43:42,310
мы начнем искать локальный
максимум в строке с индексом i.

851
00:43:42,310 --> 00:43:47,470


852
00:43:47,470 --> 00:43:50,041
Я стою здесь
и я счастлив.

853
00:43:50,041 --> 00:43:50,540
Так?

854
00:43:50,540 --> 00:43:53,440
Потому что я
говорю "Вау".

855
00:43:53,440 --> 00:43:56,850
Я выбрал средний столбец,
нашел в нем локальный максимум,

856
00:43:56,850 --> 00:44:01,350
это делается за θ(m), как
мы доказали ранее.

857
00:44:01,350 --> 00:44:06,665
И как только я...
θ(m)?..

858
00:44:06,665 --> 00:44:07,659
ГОЛОС ИЗ АУДИТОРИИ: log(n).

859
00:44:07,659 --> 00:44:08,700
ПРОФЕССОР: О, простите.

860
00:44:08,700 --> 00:44:09,730
Вы правы.

861
00:44:09,730 --> 00:44:13,490
Имелась в виду
сложность порядка log(n).

862
00:44:13,490 --> 00:44:15,031
Вот, мы доказали это здесь.

863
00:44:15,031 --> 00:44:15,530
Так.

864
00:44:15,530 --> 00:44:16,470
Сложность порядка log(n).

865
00:44:16,470 --> 00:44:18,920
Спасибо, Эрик.

866
00:44:18,920 --> 00:44:26,130
И когда я сделал это, я могу найти
локальный максимум в строке i.

867
00:44:26,130 --> 00:44:28,690
В нашем случае в строке i
содержится m элементов,

868
00:44:28,690 --> 00:44:30,630
поэтому мы найдем
максимум за log(m).

869
00:44:30,630 --> 00:44:33,840
Если n равно m, тогда я просто
делаю порядка log(n) действий

870
00:44:33,840 --> 00:44:35,050
и нахожу локальный максимум.

871
00:44:35,050 --> 00:44:36,030
Верно?

872
00:44:36,030 --> 00:44:38,320
Я нахожу локальный максимум?

873
00:44:38,320 --> 00:44:39,640
Нет.

874
00:44:39,640 --> 00:44:42,770
Кто может объяснить,
почему я не найду его?

875
00:44:42,770 --> 00:44:43,270
Точно объяснить?

876
00:44:43,270 --> 00:44:43,947
Да.

877
00:44:43,947 --> 00:44:46,841
ГОЛОС ИЗ АУДИТОРИИ: Потому что
когда вы делаете вторую часть работы

878
00:44:46,841 --> 00:44:50,155
по поиску локального максимума
в строке i, тот элемент, который

879
00:44:50,155 --> 00:44:52,987
вы найдете, может не являться
локальным максимумом

880
00:44:52,987 --> 00:44:54,320
в том столбце, где
находится этот элемент.

881
00:44:54,320 --> 00:44:56,240
ПРОФЕССОР: Это
абсолютно верно.

882
00:44:56,240 --> 00:44:59,280
Поэтому алгоритм некорректен.

883
00:44:59,280 --> 00:44:59,780
Понятно почему?

884
00:44:59,780 --> 00:45:01,460
Он не работает.

885
00:45:01,460 --> 00:45:04,380
Хотя он и эффективен,
но он некорректен.

886
00:45:04,380 --> 00:45:05,390
Ясно?

887
00:45:05,390 --> 00:45:07,215
Ваши алгоритмы должны
быть корректны.

888
00:45:07,215 --> 00:45:09,640
Знаете, корректный и
неэффективный алгоритм

889
00:45:09,640 --> 00:45:13,580
определенно лучше, чем
неэффективный. Простите,

890
00:45:13,580 --> 00:45:15,790
лучше, чем эффективный,
но некорректный.

891
00:45:15,790 --> 00:45:17,870
Наш алгоритм
эффективный,

892
00:45:17,870 --> 00:45:22,077
в том смысле, что ему нужно
порядка log(n) времени,

893
00:45:22,077 --> 00:45:22,910
но он не работает.

894
00:45:22,910 --> 00:45:25,620
Я могу привести
простой пример,

895
00:45:25,620 --> 00:45:27,650
когда он не
будет работать.

896
00:45:27,650 --> 00:45:32,490


897
00:45:32,490 --> 00:45:35,680
Проблема в том, что

898
00:45:35,680 --> 00:45:39,960
двумерного
локального максимума

899
00:45:39,960 --> 00:45:44,150
может не быть

900
00:45:44,150 --> 00:45:46,090
в строке i.

901
00:45:46,090 --> 00:45:47,700
И вот вам такой пример.

902
00:45:47,700 --> 00:45:53,640


903
00:45:53,640 --> 00:45:58,360
Кстати, это пример
вот этого случая.

904
00:45:58,360 --> 00:46:02,690
Допустим, я
начал с этой строки.

905
00:46:02,690 --> 00:46:05,057
Тогда я начинаю
со среднего столбца,

906
00:46:05,057 --> 00:46:06,890
я мог бы начать
с этого или этого.

907
00:46:06,890 --> 00:46:10,640
Допустим я начал
вот с этого.

908
00:46:10,640 --> 00:46:16,350
И начинаю искать
локальный максимум.

909
00:46:16,350 --> 00:46:22,330
И если бы здесь, сверху, стояло
10, максимумом было бы 12.

910
00:46:22,330 --> 00:46:25,856
Может так случиться, что я  верну
12 в качестве локального максимума.

911
00:46:25,856 --> 00:46:27,900
Даже несмотря на то, что
19 больше 12. Потому что 12

912
00:46:27,900 --> 00:46:30,370
больше своих соседей
10 и 11.

913
00:46:30,370 --> 00:46:33,060
И затем я выбираю
эту строку и ищу

914
00:46:33,060 --> 00:46:36,720
локальный максимум в ней.
Им было бы число 14.

915
00:46:36,720 --> 00:46:38,870
Это одномерный локальный
максимум в этой строке.

916
00:46:38,870 --> 00:46:41,840
Но 14 не является двумерным
локальным максимумом.

917
00:46:41,840 --> 00:46:42,790
Ясно?

918
00:46:42,790 --> 00:46:47,402
То есть в этом примере
мы бы вернули 14.

919
00:46:47,402 --> 00:46:50,740
Но 14 не является двумерным
локальным максимумом.

920
00:46:50,740 --> 00:46:53,730
Это понятно?

921
00:46:53,730 --> 00:46:57,460
Вы можете забрать вашу
подушку после лекции.

922
00:46:57,460 --> 00:47:01,880
Итак, это плохо.

923
00:47:01,880 --> 00:47:05,430
Похоже, что алгоритм
эффективный, но нерабочий.

924
00:47:05,430 --> 00:47:06,180
Верно?

925
00:47:06,180 --> 00:47:09,290
Как же нам прийти к тому,
что действительно работает?

926
00:47:09,290 --> 00:47:14,300
Что ж, остался последний алгоритм,
который я собираюсь вам показать.

927
00:47:14,300 --> 00:47:16,920
И вы увидите четыре
различных алгоритма

928
00:47:16,920 --> 00:47:21,260
в вашем домашнем задании.

929
00:47:21,260 --> 00:47:24,340
Вам нужно будет проанализировать
их сложность и решить,

930
00:47:24,340 --> 00:47:28,180
эффективны ли они
и корректны ли.

931
00:47:28,180 --> 00:47:33,440
Наш последний
алгоритм рекурсивный.

932
00:47:33,440 --> 00:47:37,650
С точки зрения
сложности он лучше, чем

933
00:47:37,650 --> 00:47:40,120
алгоритм жадного
восхождения.

934
00:47:40,120 --> 00:47:43,410
И он рабочий.

935
00:47:43,410 --> 00:47:46,470
Сперва я выбираю
средний столбец.

936
00:47:46,470 --> 00:47:49,750


937
00:47:49,750 --> 00:47:51,435
Обозначим его индексом
j равным m/2, как и раньше.

938
00:47:51,435 --> 00:47:54,050


939
00:47:54,050 --> 00:48:02,480
Затем я нахожу глобальный
максимум в столбце j.

940
00:48:02,480 --> 00:48:05,316


941
00:48:05,316 --> 00:48:06,690
Обозначим глобальный
максимум как (i, j).

942
00:48:06,690 --> 00:48:09,580


943
00:48:09,580 --> 00:48:18,230
Я сравниваю элементы
(i, j - 1), (i, j)

944
00:48:18,230 --> 00:48:20,440
и (i, j+1)

945
00:48:20,440 --> 00:48:23,620
То есть, после того, как я нашел
максимум в этой строке,

946
00:48:23,620 --> 00:48:25,890
я смотрю
налево и направо

947
00:48:25,890 --> 00:48:27,920
и сравниваю.

948
00:48:27,920 --> 00:48:30,825
Далее я выбираю
столбцы слева.

949
00:48:30,825 --> 00:48:33,520


950
00:48:33,520 --> 00:48:40,890
Если (i, j - 1)
больше, чем (i, j)

951
00:48:40,890 --> 00:48:42,420
и аналогично для правых.

952
00:48:42,420 --> 00:48:49,490


953
00:48:49,490 --> 00:48:55,720
На самом деле, если
ни одно из этих условий

954
00:48:55,720 --> 00:49:00,210
не выполняется
и, в то же время, (i, j)

955
00:49:00,210 --> 00:49:04,280
больше либо
равно (i, j - 1)

956
00:49:04,280 --> 00:49:07,630
и (i, j + 1), это означает,
что мы нашли максимум.

957
00:49:07,630 --> 00:49:12,760
Точно так же, как и в
одномерном случае.

958
00:49:12,760 --> 00:49:17,500
Если (i, j) больше
либо равно (i, j-1)

959
00:49:17,500 --> 00:49:26,350
и больше либо равно
(i, j+1), это означает то, что

960
00:49:26,350 --> 00:49:28,591
(i, j) - двумерный
локальный максимум.

961
00:49:28,591 --> 00:49:29,212
Ясно?

962
00:49:29,212 --> 00:49:30,670
Причина этого
состоит в том, что

963
00:49:30,670 --> 00:49:35,902
(i, j) - максимальный
элемент в столбце.

964
00:49:35,902 --> 00:49:37,360
Вы сравнили его со
всеми элементами,

965
00:49:37,360 --> 00:49:41,520
которые находятся выше
и ниже его и знаете,

966
00:49:41,520 --> 00:49:43,000
что он максимальный.

967
00:49:43,000 --> 00:49:45,150
Дальше вы посмотрели
налево и направо

968
00:49:45,150 --> 00:49:47,750
и поняли, что он также
больше либо равен элементов

969
00:49:47,750 --> 00:49:49,110
слева и справа.

970
00:49:49,110 --> 00:49:51,290
Значит, это - двумерный
локальный максимум.

971
00:49:51,290 --> 00:49:52,270
С этим понятно?

972
00:49:52,270 --> 00:49:57,710
То есть, когда вы выбираете
левые или правые столбцы,

973
00:49:57,710 --> 00:49:59,570
а вы выбираете какие-то
одни - или те, или другие, -

974
00:49:59,570 --> 00:50:08,025
вы решаете новую задачу, в которой
количество столбцов вдвое меньше.

975
00:50:08,025 --> 00:50:16,540


976
00:50:16,540 --> 00:50:17,580
Понятно?

977
00:50:17,580 --> 00:50:20,965
И опять же, вы должны
проанализировать

978
00:50:20,965 --> 00:50:24,950
или доказать это, чтобы убедиться
в том, что алгоритм корректен.

979
00:50:24,950 --> 00:50:29,740
В данном случае, корректность
интуитивна, просто потому, что

980
00:50:29,740 --> 00:50:33,190
он алгоритм похож на
одномерную версию.

981
00:50:33,190 --> 00:50:37,870
И еще у вас есть условие того, когда
нужно остановиться, вот здесь,

982
00:50:37,870 --> 00:50:41,160
то есть когда вы нашли двумерный
максимум. Как и в одномерном случае.

983
00:50:41,160 --> 00:50:43,930
И все, что вы делаете -

984
00:50:43,930 --> 00:50:46,190
делите матрицу наполовину.

985
00:50:46,190 --> 00:50:51,090
Это основа работы
алгоритма.

986
00:50:51,090 --> 00:50:55,806
В случае, если у вас
есть только один столбик,

987
00:50:55,806 --> 00:51:01,070


988
00:51:01,070 --> 00:51:09,610
найдите глобальный
максимум и готово.

989
00:51:09,610 --> 00:51:10,110
Понятно, да?

990
00:51:10,110 --> 00:51:12,570
Это базовый случай.

991
00:51:12,570 --> 00:51:14,670
Позвольте мне закончить
тем, что я напишу

992
00:51:14,670 --> 00:51:17,870
рекуррентное соотношение,
описывающее сложность этой штуки

993
00:51:17,870 --> 00:51:22,481
и покажу, чему равна общая
асимптотическая сложность

994
00:51:22,481 --> 00:51:22,980
алгоритма.

995
00:51:22,980 --> 00:51:25,221


996
00:51:25,221 --> 00:51:26,720
И после этого я сообщу
вам плохие новости.

997
00:51:26,720 --> 00:51:30,781


998
00:51:30,781 --> 00:51:31,280
Хорошо.

999
00:51:31,280 --> 00:51:36,260
Итак, в конечном итоге вот,
что у вас есть. Что-то вроде T(n, m)

1000
00:51:36,260 --> 00:51:42,570
равняется
T(n,m/2) + θ(n)

1001
00:51:42,570 --> 00:51:43,640
Почему так?

1002
00:51:43,640 --> 00:51:47,830
n - это количество строк,
m - количество столбцов.

1003
00:51:47,830 --> 00:51:51,430
В одном случае, вы
разобьете столбцы

1004
00:51:51,430 --> 00:51:54,630
на половину,
то есть m/2.

1005
00:51:54,630 --> 00:51:57,520
А для того, чтобы найти
глобальный максимум,

1006
00:51:57,520 --> 00:52:00,220
вам потребуется
θ(n) времени, так как

1007
00:52:00,220 --> 00:52:01,495
вы ищите глобальный
максимум.

1008
00:52:01,495 --> 00:52:01,995
Так?

1009
00:52:01,995 --> 00:52:05,270
Вам просто нужно
просмотреть элементы.

1010
00:52:05,270 --> 00:52:08,840
Этот способ требует
вот столько времени.

1011
00:52:08,840 --> 00:52:11,960
И если вы сделаете так
и развернете рекурсию,

1012
00:52:11,960 --> 00:52:16,210
а вы знаете, что T(n, 1)
равняется θ(n).

1013
00:52:16,210 --> 00:52:20,880
Это ваш базовый случай.
Последний кусочек здесь, на доске.

1014
00:52:20,880 --> 00:52:28,560
Тогда вы получите, что
Т(n, m) = θ(n) + ... + θ(n)

1015
00:52:28,560 --> 00:52:34,820
Количество слагаемых
здесь равно log2(m).

1016
00:52:34,820 --> 00:52:42,250
И это равняется
θ(n * log2(m))

1017
00:52:42,250 --> 00:52:43,640
Понятно?

1018
00:52:43,640 --> 00:52:48,120
Вас ждет кое-что еще касательно
поиска локального максимума.

1019
00:52:48,120 --> 00:52:53,082
Вы получите четыре алгоритма,
реализованных на Python.

1020
00:52:53,082 --> 00:52:55,290
Я не собираюсь рассказывать
вам о том, что это за алгоритмы,

1021
00:52:55,290 --> 00:52:57,090
но вы должны
узнать их.

1022
00:52:57,090 --> 00:53:00,180
Вы уже видели версии
этих алгоритмов

1023
00:53:00,180 --> 00:53:01,850
во время лекции.

1024
00:53:01,850 --> 00:53:06,210
И как я сказал ранее, вашей
задачей будет сделать

1025
00:53:06,210 --> 00:53:09,690
анализ алгоритмов, доказать,
что один из них корректен,

1026
00:53:09,690 --> 00:53:12,784
и найти контрпримеры для
тех из них, что содержат ошибки.

1027
00:53:12,784 --> 00:53:14,200
Лекторы курса
будут здесь.

1028
00:53:14,200 --> 00:53:17,110
Вы можете задать
свои вопросы

1029
00:53:17,110 --> 00:53:18,990
касательно лекции.

1030
00:53:18,990 --> 00:53:21,650
И я должен тому
джентельмену подушку.

1031
00:53:21,660 --> 00:53:24,150
Переведено на Нотабеноиде
http://translate.kursomir.ru/book/79/428

1032
00:53:24,160 --> 00:53:25,150
Переводчики: smiling_giraffe, mummick

